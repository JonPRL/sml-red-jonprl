Def HasAllPaths(#C) = [(-> [c c' : #C] (path {_} #C c c'))].

Def IsContr(#C) = [(* [c : #C] (HasAllPaths #C))].

Def Fiber(#A;#B;#f;#b) = [
  (record
    [pt : #A]
    [ray : (path {_} #B ($ #f pt) #b)])
].

Def IsEquiv(#A;#B;#f) = [(-> [b : #B] (IsContr (Fiber #A #B #f b)))].

Def Equiv(#A;#B) = [(* [f : (-> #A #B)] (IsEquiv #A #B f))].


Def Iso(#A; #B) = [
  (record
   [to : (-> #A #B)]
   [from : (-> #B #A)]
   [coh1 : (-> [b : #B] (path {_} #B ($ to ($ from b)) b))]
   [coh2 : (-> [a : #A] (path {_} #A ($ from ($ to a)) a))])
].


Thm Path/Symm{l:lvl} : [
  (->
   [ty : (U l kan)]
   [a b : ty]
   (path {_} ty a b)
   (path {_} ty b a))
] by [
  lam ty, a, b, pab.
    <i>
      `(hcom{0 ~> 1} ,ty ,a
        [i=0 {j} (@ ,pab j)]
        [i=1 {_} ,a])
].


Thm Adointify{l:lvl} : [
  (->
   [ty1 : (U l kan)]
   [ty2 : (U l kan)]
   (Iso ty1 ty2)
   (Equiv ty1 ty2))
] by [
  lam ty1, ty2, <to, from, coh1, coh2>.
    <proj1 = use to,
     proj2 =
       lam b.
         <proj1 =
          <pt = use from [use b],
           ray = <i>
             use {Path/Symm l}
               [use ty2,
                use to [use from [use b]],
                use b,
                use coh1 [use b],
                @i]>,
          proj2 =
            lam fib1, fib2.
              ?oh-dear>>
].
