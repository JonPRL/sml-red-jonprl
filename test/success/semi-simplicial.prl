Tac EqNatRec = [
  query gl <- goal.
  match [gl:jdg] {
    [n,z,s,ty | #jdg{(nat-rec %n %z [x y] (%s x y)) in %ty} => {
      refine nat/eq/nat-rec; [`%ty]; auto
    }]
  }
].

Tac At0 = [
  query gl <- goal.
  match [gl:jdg] {
    [ty | #jdg{%ty type} => {
      let p : [%ty type at 0] = internalize. auto
    }]
    [ty | #jdg{%ty type at 0} => { // this should be "at %l"
      let p : [%ty type at 0] = internalize. auto
    }]
  }
].

Tac NatArg = [
  query gl <- goal.
  match [gl:jdg] {
    [tm, ty | #jdg{%tm in %ty} => {
      refine dfun/eq/app; [`(-> nat %ty)]; auto
    }]
    [tm, ty | #jdg{%tm in %ty at 0} => {
      refine dfun/eq/app; [`(-> nat %ty)]; auto
    }]
  }
].

Thm Pick : [
  // pick #(first argument) from #(second argument)
  (-> nat nat (U 0))
] by [
  lam n. fresh n', n'/ih -> elim n;
  [ lam n. `record
  , lam m. fresh m', m'/ih -> elim m;
    [ `void
    , `(record
        [head : bool]
        [tail : (if head ($ ,n'/ih ,m') ,m'/ih)]
       )
    ]
  ];
  internalize; auto
].

Thm Pick/compose : [
  (->
   [a b c : nat]
   ($ Pick b c)
   ($ Pick a b)
   ($ Pick a c))
] by [
  lam a. fresh a', a'/ih -> elim a;
  [ lam b, c, p1, p2. `tuple
  , lam b. fresh b', b'/ih -> elim b;
    [ lam c, p1, p2. unfold Pick in p2; reduce in p2; elim p2
    , lam c. fresh c', c'/ih -> elim c;
      [ lam p1. unfold Pick in p1; reduce in p1; elim p1
      , lam p1. unfold Pick in p1; reduce in p1;
        let < head = p1/h, tail = p1/t > = p1. elim p1/h; reduce in p1/t;
        [ lam p2. unfold Pick in p2; reduce in p2;
          let < head = p2/h, tail = p2/t > = p2. elim p2/h; reduce in p2/t;
          unfold Pick in goal; reduce in goal;
          [ < head = `tt
            , tail = `($ ,a'/ih ,b' ,c' ,p1/t ,p2/t)
            >
          , < head = `ff
            , tail = `($ ,b'/ih ,c' ,p1/t ,p2/t)
            >
          ]
        , lam p2. unfold Pick in p2; reduce in p2;
          unfold Pick in goal; reduce in goal;
          < head = `ff
          , tail = `($ ,c'/ih ,p1/t ,p2)
          >
        ]
      ]
    ]
  ];

  // one line to solve all well-formedness goals
  At0; <| <| EqNatRec; internalize |> || id |>; NatArg; EqNatRec; EqNatRec; internalize; auto
].
