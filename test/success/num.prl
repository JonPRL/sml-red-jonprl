Thm One : [
  1 in int
] by [
  auto
].

Thm NegOne : [
  -1 in int
] by [
  auto
].

Thm NatOne : [
  1 in nat
] by [
  auto
].

Thm Pred : [
  (-> nat nat)
] by [
  lam a.
  fresh a', ind -> elim a;
  [ `zero ];
  [ `,a' ]
].

Extract Pred.

Def Pred2 = [
  (lam [x] (nat-rec x zero [y z] y))
].

Extract Pred2.

// A tactic to infer and supply a simple (non-dependent) motive to the nat/eq/nat-rec rule.
Tac SimpleNatRecEq = [
  query gl <- goal.
  match [gl:jdg] {
    [n,z,s,ty | #jdg{(nat-rec %n %z [x y] (%s x y)) in %ty} => {
      refine nat/eq/nat-rec; [`%ty]; auto
    }]
  }
].

Thm Pred2Wf : [
  Pred2 in (-> nat nat)
] by [
  auto;
  SimpleNatRecEq
].

Thm Plus : [
  (-> nat nat nat)
] by [
  lam a.
  fresh a', ind -> elim a;
  [ lam x. use x
  , lam x. let ih/x = ind [use x]. `(succ ,ih/x)
  ]
].

Extract Plus.

Def Plus2 = [
  (lam [a]
   (nat-rec
    a
    (lam [x] x)
    [a' ind] (lam [x] (succ ($ ind x)))))
].

Thm Plus2Wf : [
  Plus2 in (-> nat nat nat)
] by [
  auto; SimpleNatRecEq
].

Thm Plus2UnitL : [
  n : nat >> ($ Plus2 0 n) = n in nat
] by [
  auto
].


Thm NatSymm : [
  (->
   [a b : nat]
   (path {_} nat a b)
   (path {_} nat b a))
] by [
  lam a, b, pab.
  <i>
    `(hcom{0 ~> 1} nat ,a 
      [i=0 {j} (@ ,pab j)]
      [i=1 {_} ,a])
].

Print NatSymm.

Thm IntPred : [
  (-> int int)
] by [
  lam a. fresh a', junk -> elim a;
  [ `-1, fresh n, junk -> elim a'; [`0, `(succ ,n)]
  , `-2, `(negsucc (succ (succ ,a')))
  ]
].

Thm IntSucc : [
  (-> int int)
] by [
  lam a. fresh a', junk -> elim a;
  [ `1, `(succ (succ ,a'))
  , `0, `(negsucc ,a')
  ]
].

Thm IntPlus : [
  (-> int int int)
] by [
  lam a. fresh a', ind -> elim a;
  [ lam b. use b
  , lam b. `($ IntSucc ($ ,ind ,b))
  , lam b. `($ IntPred ,b)
  , lam b. `($ IntPred ($ ,ind ,b))
  ]
].

Thm Int4Plus3 : [
  ($ IntPlus 4 3) = 7 in int
] by [ auto ].

Thm Int-6Plus10 : [
  ($ IntPlus -6 10) = 4 in int
] by [ auto ].

Thm Int-1Plus-9 : [
  ($ IntPlus -1 -9) = -10 in int
] by [ auto ].
