Def HasAllPaths (#C) = [(-> [c c' : #C] (path {_} #C c c'))].

Def IsContr (#C) = [(* [c : #C] (HasAllPaths #C))].

Def Fiber (#A;#B;#f;#b) = [(* [a : #A] (path {_} #B ($ #f a) #b))].

Def IsEquiv (#A;#B;#f) = [(-> [b : #B] (IsContr (Fiber #A #B #f b)))].

Def Equiv (#A;#B) = [(* [f : (-> #A #B)] (IsEquiv #A #B f))].

Def Id = [(lam [a] a)].

Thm IdIsEquiv (#A) : [
  #A hcom type
  >>
  (IsEquiv #A #A Id)
] by [
  unfold IsEquiv; unfold IsContr; unfold Fiber; unfold HasAllPaths;
  lam a.
  < proj1 =
     <proj1 = use a,
      proj2 = <_> use a>
  , proj2 =
     lam <proj2 = c>, <proj2 = c'>. <i>
       < proj1 =
          `(hcom{1~>0} #A ,a
            [i=0 {j} (@ ,c j)]
            [i=1 {j} (@ ,c' j)])
       , proj2 =
           <j> `(hcom{1~>j} #A ,a
                 [i=0 {j} (@ ,c j)]
                 [i=1 {j} (@ ,c' j)])
       >
  >
].

Thm IdEquiv (#A) : [
  #A hcom type
  >>
  (Equiv #A #A)
] by [
  `(tuple Id (IdIsEquiv #A))
].

Thm IdUnivalence {i:dim} (#A) : [
  #A hcom type
  >>
  (ua{i} #A #A (IdEquiv #A)) type
] by [
  auto
].
