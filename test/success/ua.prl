Def HasAllPaths (#C) = [(-> [c c' : #C] (path {_} #C c c'))].

Def IsContr (#C) = [(* [c : #C] (HasAllPaths #C))].

Def Fiber (#A;#B;#f;#b) = [(* [a : #A] (path {_} #B ($ #f a) #b))].

Def IsEquiv (#A;#B;#f) = [(-> [b : #B] (IsContr (Fiber #A #B #f b)))].

Def Equiv (#A;#B) = [(* [f : (-> #A #B)] (IsEquiv #A #B f))].

Def Id = [(lam [a] a)].

Thm IdIsEquiv (#A) : [
  #A hcom type
  >>
  (IsEquiv #A #A Id)
] by [
  unfold IsEquiv;
  fresh a -> refine dfun/intro;
  [ unfold IsContr;
    [ refine record/intro;
      [ `(tuple ,a (abs {_} ,a))
      , unfold HasAllPaths;
        lam c, c'. <i>
	  `(tuple
	    (hcom{1~>0} #A ,a [i=0 {j} (@ (! proj2 ,c) j)] [i=1 {j} (@ (! proj2 ,c') j)])
	    (abs {j} (hcom{1~>j} #A ,a [i=0 {j} (@ (! proj2 ,c) j)] [i=1 {j} (@ (! proj2 ,c') j)])))
      , auto
      ]
    ]
  , auto
  ]
].

Thm IdEquiv (#A) : [
  #A hcom type
  >>
  (Equiv #A #A)
] by [
  `(tuple Id (IdIsEquiv #A))
].

Thm IdUnivalence {i:dim} (#A) : [
  #A hcom type
  >>
  (ua{i} #A #A (IdEquiv #A)) type
] by [
  auto
].
