Thm IntSucc : [
  (-> int int)
] by [
  lam i. `(int-rec i 1 [n _] (succ (succ n)) 0 [n _] (negsucc n));
    refine int/eq/int-rec; [ `int ]; auto
].

Thm IntPred : [
  (-> int int)
] by [
  lam i. `(int-rec i -1 [n _] (nat-rec n 0 [n _] (succ n)) -2 [n _] (negsucc (succ (succ n))));
    refine int/eq/int-rec; [ `int ]; auto;
    refine nat/eq/nat-rec; [ `int ]; auto
].

Thm IntSuccIntPred : [
  (-> [i : int] (= int ($ IntSucc ($ IntPred i)) i))
] by [
  lam i. fresh n -> elim i;
    [ auto
    , elim n; auto
    , auto
    , auto
    ]
].

Thm IntPredIntSucc : [
  (-> [i : int] (= int ($ IntPred ($ IntSucc i)) i))
] by [
  lam i. fresh n -> elim i;
    [ auto
    , auto
    , auto
    , elim n; auto
    ]
].

Def HasAllPathsTo (#C,#c) = [(-> [c' : #C] (path [_] #C c' #c))].

Def IsContr (#C) = [(* [c : #C] (HasAllPathsTo #C c))].

Def Fiber (#A,#B,#f,#b) = [(* [a : #A] (path [_] #B ($ #f a) #b))].

Def IsEquiv (#A,#B,#f) = [(-> [b : #B] (IsContr (Fiber #A #B #f b)))].

Def Equiv (#A,#B) = [(* [f : (-> #A #B)] (IsEquiv #A #B f))].

Thm IntSuccIsEquiv : [
  (IsEquiv int int IntSucc)
] by [
  lam i.
    let eq : [(= int ($ IntSucc ($ IntPred i)) i)] = `($ IntSuccIntPred i).
            fresh eq' -> elim eq; unfold [IntSucc, IntPred] in eq'; reduce in eq';
    {
      {`($ IntPred i), <_> `i}
    , lam {i',p'}.
        let eq0 : [(= int i ($ IntSucc i'))] = `(coe 1~>0 [x] (= int i (@ p' x)) ax).
        let eq1 : [(= int ($ IntPred i) i')] =
          fresh i'' -> rewrite eq0;
          [`(= int ($ IntPred i'') i'), `($ IntPredIntSucc i')];
          auto.
        reduce in [eq0, eq1];
        (<x>
          {`($ IntPred i), <y> `(hcom 1~>y int i [x=0 [y] (@ p' y)] [x=1 [_] i])}
        ); fresh eq1' -> elim eq1; unfold IntPred in eq1'; reduce in eq1'; auto
    }
].

Thm IntSuccEquiv : [
  (Equiv int int)
] by [
  {`IntSucc, `IntSuccIsEquiv}
].
