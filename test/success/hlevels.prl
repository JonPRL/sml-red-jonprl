Def HasAllPathsTo (#C,#c) = [(-> [c' : #C] (path [_] #C c' #c))].
Def IsContr (#C) = [(* [c : #C] (HasAllPathsTo #C c))].
Def IsProp (#A) = [(-> [a b : #A] (path [_] #A a b))].
Def IsSet (#A) = [(-> [a b : #A] (IsProp (path [_] #A a b)))].

Thm InhPropIsContr(#l:lvl) : [
 (->
  [ty : (U #l kan)] // can I use pre here?
  [h : (IsProp ty)]
  [a : ty]
  (IsContr ty))
] by [
  unfold IsProp;
  lam ty, h, a. {use a,lam x. `($ h x a)}
].

Thm PropPi(#l:lvl) : [
 (->
  [tyA : (U #l kan)]
  [tyB : (-> tyA (U #l kan))]
  [h : (-> [x : tyA] (IsProp ($ tyB x)))]
  (IsProp (-> [x : tyA] ($ tyB x))))
] by [
  unfold IsProp; lam tyA, tyB, h, f, g.
  <i> lam x. `(@ ($ h x ($ f x) ($ g x)) i)
].

Thm PropSet(#l:lvl) : [
  (->
   [tyA : (U #l kan)]
   [h : (IsProp tyA)]
   (IsSet tyA)
  )
] by [
  // unfold IsSet, IsProp; // why can't I chain unfolds like I can for lam?
  unfold IsSet; unfold IsProp; // why do I need a ; and not .?
  lam tyA, h, a, b, p, q.
  <j i> `(hcom 0~>1 tyA a
               [i=0 [k] (@ ($ h a a) k)]
               [i=1 [k] (@ ($ h a b) k)]
               [j=0 [k] (@ ($ h a (@ p i)) k)]
               [j=1 [k] (@ ($ h a (@ q i)) k)])
].

// // This proof should be easy, but it is not...
// Thm IsPropIsProp(#l:lvl) : [
//   (->
//    [tyA : (U #l kan)]
//    (IsProp (IsProp tyA))
//   )
// ] by [
//   unfold IsProp; // If I don't unfold here I get a ton of obligations...
//   lam tyA, h1, h2. // why is 1 and 2 blue?
//   <i> lam a, b.
//   // I want to write something simple like this:
//   // `(@ (PropSet #l tyA h1 a b ($ h1 a b) ($ h2 a b)) i)
//   // But that gives 10 obligations, so I try to manually instantiate the lemma
//   let foo : [(IsSet tyA)] = `(PropSet #l tyA h1).
//   unfold IsSet; unfold IsProp;
//   let bar : [(path [_] (path [_] tyA a b) ($ h1 a b) ($ h2 a b))] =
//     `($ foo a b ($ h1 a b) ($ h2 a b)).
//   `(@ bar i)
//   // But this gives 29 obligations... ugh, giving up!
// ].

// // This should be exactly like the one above:
// Thm IsPropIsSet(#l:lvl) : [
//   (->
//    [tyA : (U #l kan)]
//    (IsProp (IsSet tyA))
//   )
//  ] by [
//   ?hole
// ].
