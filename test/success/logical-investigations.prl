// Some theorems from http://www.nuprl.org/MathLibrary/LogicalInvestigations/.

// We will prove the theorem A -> B -> A. In a traditional proof assistant for type theory, the 
// types/propositions A, B would be quantified over using dependent function types and a universe.
// However, RedPRL doesn't yet have a universe! So, what we have to do is treat A and B as parameters
// to the theorem, and add explicit *hypotheses* that they are types.
//
// In RedPRL, parameters to definitions and theorems are prefixed by a #; this distinguishes them from 
// object variables.
//
// Once we have a universe, this will be much simpler.
Thm Thm1(#A; #B) : [
  type/A : #A type,
  type/B : #B type
  >> (-> #A #B #A)
] by [
  lam a, b. use a
].

Thm Thm2(#A; #B; #C) : [
  type/A : #A type,
  type/B : #B type,
  type/C : #C type
  >> (-> (-> #A #B) (-> #A #B #C) #A #C)
] by [
  lam f, g, a.
  use g [use a, use f [use a]]
].

// It is worthwhile to print out the extract program / evidence for Thm2.
Extract Thm2.

// here's a proof using lower-level scripting
Thm Thm3/low-level(#A; #B; #C) : [
  type/A : #A type,
  type/B : #B type,
  type/C : #C type
  >> (->
      (-> #A #B)
      (-> #B #C)
      (-> #A #C))
] by [
  fresh ab, bc, a <- auto;
  fresh c <- elim bc;
  [fresh b <- elim ab; [use a, use b], use c]
].

Extract Thm3/low-level.

// here's a high-level version of the above proof. proofs using the high-level 
// programming calculus may be longer, but they are often easier to engineer, 
// and nicely segregate main goals from auxiliary goals.
Thm Thm3/high-level(#A; #B; #C) : [
  type/A : #A type,
  type/B : #B type,
  type/C : #C type
  >> (->
      (-> #A #B)
      (-> #B #C)
      (-> #A #C))
] by [
  lam ab, bc, a.
  use bc [use ab [use a]]
].

Extract Thm3/high-level.

Def Not(#A) = [ (-> #A void) ].

Thm Not/wf(#A) : [
  type/A : #A type
  >> (Not #A) type
] by [
  auto
].


Thm Thm4(#A; #B) : [
  type/A : #A type
  >> (-> (Not #A) #A #B)
] by [
  lam r, a.
  unfold Not;
  let boom = r [use a].
  elim boom
].

Thm Thm5(#A) : [
  type/A : #A type
  >> (-> #A (Not (Not #A)))
] by [
  lam a. unfold Not; lam r.
  use r [use a]
].

Print Thm4.
Print Thm5.


Thm Thm6(#A;#B) : [
  type/A : #A type,
  type/B : #B type
  >> (-> (-> #A #B) (Not #B) (Not #A))
] by [
  lam ab, nb. unfold Not; lam a.
  use nb [use ab [use a]]
].