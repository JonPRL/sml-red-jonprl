// Each declaration takes a block of parameters in square brackets (symbols w/ sorts),
// and a block of arguments in parentheses (metavariables with valences). Both
// are optional.

Def dfun(A : exp, B : [exp].exp) : exp = [
  x
].

Def mydef(M : [exp].exp, N : [tac].exp) : exp = [
  dfun(N[a <- id; hyp a]; [x].M[x])
].

// Tactics can take parameters and arguments as well
Tac welp[a:exp](M : exp) = [
  y
].

// Recursion is built into the tactic language.
Tac repeat(T : tac) = [
  rec R. {
    (T); (R)
  }
].

// Note how level polymorphism is introduced for a theorem through an *argument*.
// In Red JonPRL's semantics, this corresponds to a generic judgment.
Thm thm(i:lvl) : [
  todo
] by [
  a,c <- id;
  d,e <- id;
  [hyp d, hyp e];
  #1 {
    hyp a;
    hyp b
  }
].
