// All forms are declaration are elaborated into definitions of operators
// of a particular sort along with computation rules which are available
// to Red JonPRL's evaluator.

// Tacticals are easily defined from within JonPRL's computation system.
// Here are a few examples:
Tac repeat(T : tac) = [
  rec R. {
    T; R
  }
].

Sym testsymdecl : exp.


Tac complete(T : tac) = [
  T; fail
].

Def id(M : exp) : exp = [
  M
].

// In addition, operators can take symbolic parameters (in brackets, as in PFPL);
// furthermore, the arguments of operators may bind both symbols (in braces) and
// variables (in brackets). Arguments of an operator are treated as metavariables
// of the appropriate valence in the body of the definiens.
Def welp[a:exp](E : {exp}[exp].exp) : exp = [
  E{a}[Ax]
].


// Theorems may be both parametric and general. Let's prove an easy theorem by exploiting the
// computation rule for [welp].
Thm example[a:exp] : [~(Base; welp[a]({b}[x].Base))] by [
  csym;
  ceval
].

// Every proof is related to the evidence semantics of Computational Type Theory by
// an 'extract'; a theorem in JonPRL, like every other declaration form, is a
// definitional extension of the ambient signature, and is elaborated so as to include
// its extract. There is a non-canonical operator that can be used to pull out the
// extract of a theorem. We can prove that the extract of the [example] theorem is
// the trivial term [Ax]:
Thm extractTest[z:exp] : [~(extract(example[z]); Ax)] by [
  ceval
].

Thm univTest(i : lvl) : [=(Univ(i); Univ(i); Univ(lsuc(i)))] by [
  eq
].


Thm baseTypeEq(i : lvl) : [=(Base; Base; Univ(i))] by [
  eq
].

Tac crefl = [
  cstep{0}
].

Thm baseMemberEq : [=(Ax; Ax; Base)] by [
  eq; crefl
].

// Ensembles, or subtype comprehensions, are types that restrict the inhabitants of
// a type by a predicate. Because this is a multi-sorted type theory, we must specify
// what syntactic sort is being refined by the type being restricted. In this example,
// we are restricting the [exp] sort, which contains type expressions.
Def ensembleExample : exp = [
  { x : Base | ~(x; Base) }
].

Tac try(t : tac) = [
  {t} || {id}
].

Thm ensembleTest : [member(Ax; {x : Base | ~(x; Ax) })] by [
  repeat(auto)
].

Thm demo : [{x : Base | ~(x; Ax)}] by [
  auto; #0 { witness [Ax] }; repeat(auto)
].

// let's declare some symbols (nominal atoms). new symbols are always fresh.
Sym mysym : exp.
Sym mysym2 : exp.
Sym yes : exp.
Sym no : exp.

// atoms can be compared for equality; here, we show that two of our
// declared atoms are distinct.
Thm atomTest : [~(ifeq('mysym; 'mysym2; 'yes; 'no); 'no)] by [
  ceval
].

Thm lamTest : [fun(Atom; Atom)] by [
  normalize;
  z <- intro;
  [ witness [ifeq(z; 'mysym; 'yes; 'no)]
  , repeat(auto)
  ];
  normalize;
  auto; auto
].

Thm apEqTest : [member(ap(lam([x].x); 'mysym); Atom)] by [
  eval-goal;
  eq;
  [ witness{lvl} [lbase]
  , witness [Atom]
  , witness [Atom]
  ]; repeat(auto);
].

//
//
//Def record(el : [exp].exp) : exp = [
//  dfun(Atom; [l]. el[l])
//].
//
//Sym foo : exp.
//Sym bar : exp.
//
//Def exampleRecordTy : exp = [
//  record([l]. ifeq(l; 'foo; Atom; ifeq(l; 'bar; Atom; Base)))
//].
//
//Def exampleRecord : exp = [
//  lam([l]. ifeq(l; 'foo; 'mysym; ifeq(l; 'bar; 'mysym2; Ax)))
//].
