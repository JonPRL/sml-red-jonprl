structure Ast = RedPrlAst
structure Ar = RedPrlArity
structure Vl = Ar.Vl
structure Tele = AstSignature.Telescope

open Ast

structure P =
struct
  open RedPrlParamData
  open RedPrlParameterTerm
end

structure O = RedPrlOpData

fun makeFunApp (m, n) =
  Ast.$$ (O.MONO O.AP, [\ (([],[]), m), \ (([],[]), n)])

fun makeFunApps [x] = x
  | makeFunApps (x :: xs) = makeFunApp (makeFunApps xs, x)
  | makeFunApps [] = raise Fail "makeFunApps"

%%
%header (functor RedPrlLrValsFun (structure Token : TOKEN))

%term
   EOF
 | IDENT of string
 | COLON
 | LPAREN
 | RPAREN
 | RBRACKET
 | LBRACKET
 | LSQUARE
 | RSQUARE
 | EQUALS
 | DOT
 | APOSTROPHE
 | ZERO
 | ONE
 | HASH
 | SEMI
 | COMMA
 | LAMBDA
 | SQUIGGLE_ARROW
 | HCOM
 | COE

 | DIM | EXN | LBL
 | EXP | LVL

 | DCL_DEF | DCL_TAC | DCL_THM
 | BY

%nonterm
   start of ast
 | term of ast
 | preterm of ast
 | binder of symbol list * symbol list
 | binding of ast abs
 | bindings of ast abs list
 | symbols of symbol list
 | param of string param
 | params of string param list
 | extents of string param list
 | terms of ast list
 | metavar of string
 | metavarArgs of string param list * ast list
 | operator of string operator
 | funapp of ast list
 | dir of string param * string param
 | psort of P.param_sort
 | sort of O.sort
 | psorts of P.param_sort list
 | sorts of O.sort list
 | bindingSig of P.param_sort list * O.sort list
 | valence of Ar.valence

 | tacticScript of ast

 | declArgument of metavariable * Ar.valence
 | declArguments of AstSignature.arguments

 | predecl of AstSignature.opid * AstSignature.decl
 | decl of AstSignature.opid * (AstSignature.decl * Pos.t option)
 | sign of AstSignature.sign

%verbose
%pos Coord.t
%start start
%eop EOF
%noshift EOF
%name RedPrl
%arg (fileName) : string
%%

start : term (term)

psort
  : DIM (P.DIM)
  | EXN (P.EXN)
  | LBL (P.LBL)

sort
  : EXP (O.EXP)
  | LVL (O.LVL)

sorts
  : ([])
  | sort ([sort])
  | sort COMMA sorts (sort :: sorts)

psorts
  : ([])
  | psort ([psort])
  | psort COMMA psorts (psort :: psorts)

bindingSig
  : LBRACKET psorts RBRACKET LSQUARE sorts RSQUARE DOT (psorts, sorts)
  | LBRACKET psorts RBRACKET DOT (psorts, [])
  | LSQUARE sorts RSQUARE DOT ([], sorts)
  | ([], [])

valence
  : bindingSig sort ((bindingSig, sort))

param
  : IDENT (P.VAR IDENT)
  | ZERO (P.APP P.DIM0)
  | ONE (P.APP P.DIM1)

params
  : ([])
  | param ([param])
  | param COMMA params (param :: params)

extents
  : param ([param])
  | param COMMA extents (param :: extents)

symbols
  : ([])
  | IDENT ([IDENT])
  | IDENT COMMA symbols (IDENT :: symbols)

terms
  : ([])
  | term ([term])
  | term COMMA terms (term :: terms)

binder
  : LBRACKET symbols RBRACKET LSQUARE symbols RSQUARE DOT (symbols1, symbols2)
  | LBRACKET symbols RBRACKET DOT (symbols, [])
  | LSQUARE symbols RSQUARE DOT ([], symbols)
  | ([], [])

binding
  : binder term (\ (binder, term))

bindings
  : ([])
  | binding ([binding])
  | binding SEMI bindings (binding :: bindings)

metavarArgs
  : LBRACKET params RBRACKET LSQUARE terms RSQUARE (params, terms)
  | LBRACKET params RBRACKET (params, [])
  | LSQUARE terms RSQUARE ([], terms)
  | ([], [])

operator
  : LAMBDA (O.MONO O.LAM)
  | HCOM LSQUARE extents SEMI dir RSQUARE (O.POLY (O.HCOM (O.TAG_NONE, extents, dir)))
  | COE LSQUARE dir RSQUARE (O.POLY (O.COE (O.TAG_NONE, dir)))
  | IDENT (O.POLY (O.CUST (IDENT, NONE)))

metavar
  : HASH IDENT (IDENT)

funapp
  : term ([term])
  | term funapp (funapp @ [term])

dir
  : param SQUIGGLE_ARROW param ((param1, param2))

term : preterm (annotate (Pos.pos preterm1left preterm1right) preterm)

preterm
  : operator LPAREN bindings RPAREN (Ast.$$ (operator, bindings))
  | metavar metavarArgs (Ast.$$# (metavar, metavarArgs))
  | IDENT (`` IDENT)
  | funapp (makeFunApps funapp)
  | LPAREN term RPAREN (term)


declArgument
  : metavar COLON valence ((metavar, valence))

declArguments
  : ([])
  | declArgument ([declArgument])
  | declArgument SEMI declArguments (declArgument :: declArguments)

predecl
  : DCL_DEF IDENT LPAREN declArguments RPAREN COLON sort EQUALS LSQUARE term RSQUARE
      (IDENT, AstSignature.DEF {arguments = declArguments, definiens = term, sort = sort})
  | DCL_TAC IDENT LPAREN declArguments RPAREN EQUALS LSQUARE tacticScript RSQUARE
      (IDENT, AstSignature.TAC {arguments = declArguments, script = tacticScript})
  | DCL_THM IDENT LPAREN declArguments RPAREN COLON LSQUARE term RSQUARE BY LSQUARE tacticScript RSQUARE
      (IDENT, AstSignature.TAC {arguments = declArguments, script = tacticScript})

decl : predecl (#1 predecl, (#2 predecl, SOME (Pos.pos predeclleft predecl1right)))

sign
  : (Tele.empty)
  | decl DOT sign (Tele.cons (#1 decl) (#2 decl) sign)

