Def pi(A : exp, B : [exp].exp) : exp ≡ [
  (x : A) B[x]
].

// Theorems induce the definition of an operator of sort [thm],
// with arguments of user-selected valences. The arguments to a theorem
// express raw generality (i.e. not functionality); we will not initially have any
// syntactic induction principles for the arguments to a theorem, but in the future
// one might imagine allowing a sort to be frozen in the style of Twelf, and generating
// an induction principle for it at the judgmental level.

// Many theorems and definitions will be generic in a universe hierarchy
// (i.e. an argument of sort [lvl]); when applying the cut rule, the referenced
// theorem must well-formed expression of sort [thm], so it will have to be supplied
// with a suitable level.

// We do not suppose there to exist any actual canonical level expressions in our
// computation system, but we do not rule them out; as a result, an induction principle
// for levels is precluded, which allows us to treat generality with respect to a universe
// hierarchy in a purely formal sense.

Thm pi-wf(i : lvl) : [
  {A : U{i}} {B : A → U{i}} pi(A; x.B[x]) ∈ U{i}
] ≡ [
  A, B ← intros;
  unfold pi;
  x ← auto;
  [ hyp-eq[A]
  , elim[B] x
  ]
].
