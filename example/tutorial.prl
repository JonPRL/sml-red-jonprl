// POPL 2018 tutorial
// January 8, 2018

Thm Not : [
  (-> bool bool)
] by [
  lam b =>
  if b then `ff else `tt
].

Print Not.

// (not(not(b)) == b) because it holds for every closed boolean.
Thm NotNot : [
  (->
   [b : bool]
   (= bool ($ Not ($ Not b)) b))
] by [
  lam b =>
  // The next four lines can be replaced by auto.
  unfold Not;
  if b
  then (reduce at left; refine bool/eq/tt)
  else (reduce at left; refine bool/eq/ff)
].

Print NotNot.

// Type families respect equality proofs.
Thm RespectEquality : [
  (->
   [family : (-> [b : bool] (U 0))]
   [b : bool]
   ($ family b)
   ($ family ($ Not ($ Not b))))
] by [
  lam family b pf =>
  rewrite ($ NotNot b);
  [ with b' => `($ family b')
  , use pf
  , auto
  , auto ]
].

// Extract does not mention the equality proof!
// (No need to ``transport'' at runtime.)
Print RespectEquality.

// In fact, all proofs of (not(not(b)) == b) are equal.
Thm EqualityIrrelevant : [
  (=
    (-> [b : bool] (= bool ($ Not ($ Not b)) b))
    NotNot
    (lam [b] ax))
] by [
  auto
].

Print EqualityIrrelevant.

// Paths (cf equalities), like those arising from
// equivalences via univalence, do induce computation.
Thm FunToPair : [
  (->
   [ty : (U 0 kan)]
   (-> bool ty)
   (* ty ty))
] by [
  lam ty fun =>
  {`($ fun tt), `($ fun ff)}
].

// {{{ Univalence

Def HasAllPathsTo (#C,#c) = [(-> [c' : #C] (path [_] #C c' #c))].
Def IsContr (#C) = [(* [c : #C] (HasAllPathsTo #C c))].
Def Fiber (#A,#B,#f,#b) = [(* [a : #A] (path [_] #B ($ #f a) #b))].
Def IsEquiv (#A,#B,#f) = [(-> [b : #B] (IsContr (Fiber #A #B #f b)))].
Def Equiv (#A,#B) = [(* [f : (-> #A #B)] (IsEquiv #A #B f))].

Thm WeakConnection(#l:lvl) : [
  (->
   [ty : (U #l hcom)]
   [a b : ty]
   [p : (path [_] ty a b)]
   (path [i] (path [_] ty (@ p i) b) p (abs [_] b)))
] by [
  (lam ty a b p =>
    abs i j =>
      `(hcom 1~>0 ty b
        [i=0 [k] (hcom 0~>j ty (@ p k) [k=0 [w] (@ p w)] [k=1 [_] b])]
        [i=1 [k] (hcom 0~>1 ty (@ p k) [k=0 [w] (@ p w)] [k=1 [_] b])]
        [j=0 [k] (hcom 0~>i ty (@ p k) [k=0 [w] (@ p w)] [k=1 [_] b])]
        [j=1 [k] (hcom 0~>1 ty (@ p k) [k=0 [w] (@ p w)] [k=1 [_] b])]))
].

Thm FunToPairIsEquiv : [
  (->
   [ty : (U 0 kan)]
   (IsEquiv (-> bool ty) (* ty ty) ($ FunToPair ty)))
] by [
  lam ty pair =>
  { { lam b => if b then `(!proj1 pair) else `(!proj2 pair)
    , abs _ => `pair }
  , unfold Fiber;
    lam {fun,p} =>
      refine path/intro; [ with x:dim =>
        {lam b => if b then `(!proj1 (@ p x)) else `(!proj2 (@ p x)),
         abs y =>
           `(@ ($ (WeakConnection #lvl{0}) (* ty ty) ($ FunToPair ty fun) pair p) x y)
        }
      ];

      [ symmetry; refine record/eq/tuple;
        [ refine fun/eq/eta; #1{auto}; auto; symmetry;
          claim p/0 : [(@ p 0) = ($ FunToPair ty fun) in (* ty ty)] by [ auto ];
          auto;
          [ rewrite p/0; [with h => `(= ty (! proj1 h) ($ fun tt))]
          , rewrite p/0; [with h => `(= ty (! proj2 h) ($ fun ff))]
          ]
        ]; auto

       , refine record/eq/tuple;
         [ auto
         , refine path/eq/abs;
           [ symmetry; unfold WeakConnection;
             reduce at right;
             refine record/eq/eta; #1 {auto};
             refine record/eq/tuple; #2 {auto};
             [ symmetry; refine hcom/eq/tube; [auto, auto, auto, auto, auto, auto, auto, auto]
             , symmetry; refine hcom/eq/tube; [auto, auto, auto, auto, auto, auto, auto, auto]
             ]
           ]
         ];
         auto
      ]
  }
].

Thm PathFunToPair : [
  (->
   [ty : (U 0 kan)]
   (path [_] (U 0 kan) (-> bool ty) (* ty ty)))
] by [
  lam ty => abs x =>
  `(V x (-> bool ty) (* ty ty)
    (tuple [proj1 ($ FunToPair ty)] [proj2 ($ FunToPairIsEquiv ty)]))
].

// }}}

Print PathFunToPair.

// We can coerce elements of (bool -> ty) to (ty * ty).
Thm RespectPaths : [
  (->
   [ty : (U 0 kan)]
   (-> bool ty)
   (* ty ty))
] by [
  lam ty fun =>
  `(coe 0~>1 [x] (@ ($ PathFunToPair ty) x) fun)
].

Print RespectPaths.

// When coercing, the choice of PathFunToPair matters!
Thm ComputeCoercion : [
  (=
   (* bool bool)
   ($ RespectPaths bool (lam [b] b))
   (tuple [proj1 tt] [proj2 ff]))
] by [
  auto
].

// ---------------------------------------------------------
// Part Two
// ---------------------------------------------------------

// A constant path does not depend on its dimension.
Thm Refl : [
  (->
   [ty : (U 0)]
   [a : ty]
   (path [_] ty a a))
] by [
  lam ty a =>
  abs _ => `a
].

// The path structure of each type is defined in terms of
// its constituent types.
Thm FunPath : [
  (->
   [a b : (U 0)]
   [f g : (-> a b)]
   (path [_] (-> a b) f g)
   [arg : a]
   (path [_] b ($ f arg) ($ g arg)))
] by [
  lam a b f g p =>
  lam arg => abs x =>
  `($ (@ p x) arg)
].

Print FunPath.

Thm PathInv : [
  (->
   [ty : (U 0 kan)]
   [a b : ty]
   [p : (path [_] ty a b)]
   (path [_] ty b a))
] by [
//        a          -- x
//     -------      |
//    |      |      y
//  p |      | a
//    |      |
//    b .... a

  lam ty a b p =>
  abs x =>
  `(hcom 0~>1 ty a [x=0 [y] (@ p y)] [x=1 [_] a])
].

Thm PathConcat : [
  (->
   [ty : (U 0 kan)]
   [a b c : ty]
   [p : (path [_] ty a b)]
   [q : (path [_] ty b c)]
   (path [_] ty a c))
] by [
//        p          -- x
//     -------      |
//    |      |      y
//  a |      | q
//    |      |
//    a .... c

  lam ty a b c p q =>
  abs x =>
  `(hcom 0~>1 ty (@ p x) [x=0 [_] a] [x=1 [y] (@ q y)])
].

Thm InvRefl : [
  (->
   [ty : (U 0 kan)]
   [a : ty]
   (path
     [_] (path [_] ty a a)
     ($ PathInv ty a a (abs [_] a))
     (abs [_] a)))
] by [
  // See diagram!
  lam ty a =>
  abs x y =>
  `(hcom 0~>1 ty a
    [x=0 [z] (hcom 0~>z ty a [y=0 [_] a] [y=1 [_] a])]
    [x=1 [_] a]
    [y=0 [_] a]
    [y=1 [_] a])
].

// Although the path type is not defined by refl and J
// (as in HoTT), we can still define J using hcom + coe.
// The #l is an example of a parametrized definition.
Thm J(#l:lvl) : [
  (->
   [ty : (U #l kan)]
   [a : ty]
   [fam : (-> [x : ty] (path [_] ty a x) (U #l kan))]
   [d : ($ fam a (abs [_] a))]
   [x : ty]
   [p : (path [_] ty a x)]
   ($ fam x p))
] by [
  lam ty a fam d x p =>
  `(coe 0~>1
    [i] ($ fam
           (hcom 0~>1 ty a [i=0 [_] a] [i=1 [j] (@ p j)])
           (abs [j] (hcom 0~>j ty a [i=0 [_] a] [i=1 [j] (@ p j)]))) d)
].

Thm JInv : [
  (->
   [ty : (U 0 kan)]
   [a b : ty]
   [p : (path [_] ty a b)]
   (path [_] ty b a))
] by [
  lam ty a b p =>
  exact
    ($ (J #lvl{0})
       ty
       a
       (lam [b _] (path [_] ty b a))
       (abs [_] a)
       b
       p)
  ; auto
  //; unfold J; reduce at left right; ?
].

Print JInv.

// Computing winding numbers in the circle.

Quit.

// Bonus material:

Thm Shannon : [
  (->
   [ty  : (-> bool (U 0))]
   [elt : (-> [b : bool] ($ ty b))]
   [b : bool]
   (= ($ ty b) ($ elt b) (if b ($ elt tt) ($ elt ff))))
] by [
  lam ty elt b =>
  elim b; auto
].

Thm WeakShannon : [
  (->
   [ty  : (-> wbool (U 0 kan))]
   [elt : (-> [b : wbool] ($ ty b))]
   [b : wbool]
   (path [_] ($ ty b) ($ elt b) (wif [b'] ($ ty b') b ($ elt tt) ($ elt ff))))
] by [
  lam ty elt b =>
  elim b; auto;
  [ abs _ => `($ elt tt)
  , abs _ => `($ elt ff)
  , auto]
].
