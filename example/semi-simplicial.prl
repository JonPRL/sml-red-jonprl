/*
  favonia:

  This formulation is strongly influenced by my own previous
  attempt in Agda (sadly not available anymore) and Hugo Herbelin's
  paper "A dependently-typed construction of semi-simplicial types".

  The most significant differences from Hugo's formulation are
  (1) the usage of `Pick` denoting the choice of subcomplex,
  and (2) the reformulation based on it to avoid additions.
*/

Thm Pick : [
  // pick #(first argument) from #(second argument)
  (-> nat nat (U 0))
] by [
  lam n => elim n;
  [ lam n => `record
  , with n'/ih n' => 
    lam m => elim m;
    [ `void
    , with m'/ih m' => 
      `(record
        [head : bool]
        [tail : (if [_] (U 0) head ($ n'/ih m') m'/ih)])
    ]
  ]
].

Thm Pick/compose : [
  (->
   [a b c : nat]
   ($ Pick b c)
   ($ Pick a b)
   ($ Pick a c))
] by [
  lam a => elim a;
  [ lam b c p0 p1 => `tuple
  , with a'/ih a' =>
    lam b => elim b;
    [ lam c p0 p1 => elim p1
    , with b'/ih b' =>
      lam c => elim c;
      [ lam p0 => elim p0
      , with c'/ih c' =>
        lam p0 =>
        let {head = p0/h, tail = p0/t} = p0; elim p0/h;
        [ lam p1 =>
          let {head = p1/h, tail = p1/t} = p1; elim p1/h;
          [ { head = `tt
            , tail = `($ a'/ih b' c' p0/t p1/t)
            }
          , { head = `ff
            , tail = `($ b'/ih c' p0/t p1/t)
            }
          ]
        , lam p1 =>
          { head = `ff
          , tail = `($ c'/ih p0/t p1)
          }
        ]
      ]
    ]
  ]
].

Thm Pick/compose/tt/4/0/tt/5/0 : [
  (->
   [a b c : nat]
   [p0/t : ($ Pick b c)]
   [p1/t : ($ Pick a b)]
   (=
    ($ Pick (succ a) (succ c))
    ($ Pick/compose (succ a) (succ b) (succ c)
       (tuple [head tt] [tail p0/t]) (tuple [head tt] [tail p1/t]))
    (tuple [head tt] [tail ($ Pick/compose a b c p0/t p1/t)])))
] by [
  lam a b c p0/t p1/t =>
    auto;
    unfold Pick; reduce; assumption
].

Thm Pick/compose/tt/4/0/ff/5/0 : [
  (->
   [a b c : nat]
   [p0/t : ($ Pick b c)]
   [p1/t : ($ Pick (succ a) b)]
   (=
    ($ Pick (succ a) (succ c))
    ($ Pick/compose (succ a) (succ b) (succ c)
       (tuple [head tt] [tail p0/t]) (tuple [head ff] [tail p1/t]))
    (tuple [head ff] [tail ($ Pick/compose (succ a) b c p0/t p1/t)])))
] by [
  lam a b c p0/t p1/t =>
    auto;
    unfold Pick; reduce; assumption
].

Thm Pick/compose/ff/4/0 : [
  (->
   [a b c : nat]
   [p0/t : ($ Pick (succ b) c)]
   [p1 : ($ Pick (succ a) (succ b))]
   (=
    ($ Pick (succ a) (succ c))
    ($ Pick/compose (succ a) (succ b) (succ c)
       (tuple [head ff] [tail p0/t]) p1)
    (tuple [head ff] [tail ($ Pick/compose (succ a) (succ b) c p0/t p1)])))
] by [
  lam a b c p0/t p1 =>
    auto; 
    unfold Pick; reduce; assumption
].

Thm Eq/inv : [
  (-> [a : (U 0)] [x y : a]
    (= a x y) (= a y x))
] by [
  lam a x y eq => assumption
].

Thm Pick/compose/assoc : [
  (->
   [a b c d : nat]
   [p0 : ($ Pick c d)]
   [p1 : ($ Pick b c)]
   [p2 : ($ Pick a b)]
   (=
    ($ Pick a d)
    ($ Pick/compose a b d ($ Pick/compose b c d p0 p1) p2)
    ($ Pick/compose a c d p0 ($ Pick/compose a b c p1 p2))))
] by [
  lam a => elim a;
  [ lam b c d p0 p1 p2 => unfold Pick/compose; auto ]; // a = 0
  with a'/ind a' => lam b => elim b;
  [ lam c d p0 p1 p2 => elim p2 ]; // b = 0
  with b'/ind b' => lam c => elim c;
  [ lam d p0 p1 => elim p1 ]; // c = 0
  with c'/ind c' => lam d => elim d;
  [ lam p0 => elim p0 ]; // d = 0
  with d'/ind d' => lam p0 =>
  let {head = p0/h, tail = p0/t} = p0; elim p0/h;
  [ lam p1 => let {head = p1/h, tail = p1/t} = p1; elim p1/h;
    [ lam p2 => let {head = p2/h, tail = p2/t} = p2; elim p2/h;
      [ rewrite ($ Pick/compose/tt/4/0/tt/5/0 b' c' d' p0/t p1/t) at left;
        [ with x => `($ Pick/compose (succ a') (succ b') (succ d') x (tuple [head tt] [tail p2/t]))
        , rewrite ($ Pick/compose/tt/4/0/tt/5/0 a' b' d' ($ Pick/compose b' c' d' p0/t p1/t) p2/t) at left;
          [ with x => `x
          , rewrite ($ a'/ind b' c' d' p0/t p1/t p2/t) at left;
            [ with x => `(tuple [head tt] [tail x])
            , rewrite ($ Pick/compose/tt/4/0/tt/5/0 a' b' c' p1/t p2/t) at right;
              [ with x => `($ Pick/compose (succ a') (succ c') (succ d') (tuple [head tt] [tail p0/t]) x)
              , rewrite ($ Pick/compose/tt/4/0/tt/5/0 a' c' d' p0/t ($ Pick/compose a' b' c' p1/t p2/t)) at right;
                [ with x => `x
                ]
              ]
            ]
          ]
        ]
      , rewrite ($ Pick/compose/tt/4/0/tt/5/0 b' c' d' p0/t p1/t) at left;
        [ with x => `($ Pick/compose (succ a') (succ b') (succ d') x (tuple [head ff] [tail p2/t]))
        , rewrite ($ Pick/compose/tt/4/0/ff/5/0 a' b' d' ($ Pick/compose b' c' d' p0/t p1/t) p2/t) at left;
          [ with x => `x
          , rewrite ($ b'/ind c' d' p0/t p1/t p2/t) at left;
            [ with x => `(tuple [head ff] [tail x])
            , rewrite ($ Pick/compose/tt/4/0/ff/5/0 a' b' c' p1/t p2/t) at right;
              [ with x => `($ Pick/compose (succ a') (succ c') (succ d') (tuple [head tt] [tail p0/t]) x)
              , rewrite ($ Pick/compose/tt/4/0/ff/5/0 a' c' d' p0/t ($ Pick/compose (succ a') b' c' p1/t p2/t)) at right;
                [ with x => `x
                ]
              ]
            ]
          ]
        ]
      ]
    , lam p2 => rewrite ($ Pick/compose/tt/4/0/ff/5/0 b' c' d' p0/t p1/t) at left;
      [ with x => `($ Pick/compose (succ a') (succ b') (succ d') x p2)
      , rewrite ($ Pick/compose/ff/4/0 a' b' d' ($ Pick/compose (succ b') c' d' p0/t p1/t) p2) at left;
        [ with x => `x
        , rewrite ($ c'/ind d' p0/t p1/t p2) at left;
          [ with x => `(tuple [head ff] [tail x])
          , rewrite ($ Pick/compose/ff/4/0 a' b' c' p1/t p2) at right;
            [ with x => `($ Pick/compose (succ a') (succ c') (succ d') (tuple [head tt] [tail p0/t]) x)
            , rewrite ($ Pick/compose/tt/4/0/ff/5/0 a' c' d' p0/t ($ Pick/compose (succ a') (succ b') c' p1/t p2)) at right;
              [ with x => `x
              ]
            ]
          ]
        ]
      ]
    ]
  , lam p1 p2 => rewrite ($ Pick/compose/ff/4/0 b' c' d' p0/t p1) at left;
    [ with x => `($ Pick/compose (succ a') (succ b') (succ d') x p2)
    , rewrite ($ Pick/compose/ff/4/0 a' b' d' ($ Pick/compose (succ b') (succ c') d' p0/t p1) p2) at left;
      [ with x => `x
      , rewrite ($ Pick/compose/ff/4/0 a' c' d' p0/t ($ Pick/compose (succ a') (succ b') (succ c') p1 p2)) at right;
        [ with x => `x
        , rewrite ($ d'/ind p0/t p1 p2) at left;
          [ with x => `(tuple [head ff] [tail x])
          ]
        ]
      ]
    ]
  ];
  auto
].

Thm MegaMutualDefs : [
  (-> nat
    (record
      [sst : (U 1)]
      [folder : (-> sst nat (U 0))]
      [proj : (-> [x : sst]
        [n m : nat] ($ Pick n m)
        ($ folder x n)
        ($ folder x m))]
      [proj-coh : (-> [x : sst] [n m o : nat]
        [c1 : ($ Pick m o)]
        [c2 : ($ Pick n m)] [f : ($ folder x n)]
        (= ($ folder x o)
          ($ proj x m o c1 ($ proj x n m c2 f))
          ($ proj x n o ($ Pick/compose n m o c1 c2) f)))]))
] by [
  lam p => elim p;
  [
    { sst = `record
    , folder = lam x n => `record
    , proj = lam x n m c f => `tuple
    , proj-coh = lam x n m o c1 c2 f => `ax
    };
  , with p'/ind p' =>
    let {sst=sst', folder=folder', proj=proj', proj-coh=proj-coh'}
      = p'/ind;
    { sst = `(* [x : sst'] (-> ($ folder' x p') (U 0)))
    , folder = lam {proj1=x, proj2=y} n =>
        `(* [f : ($ folder' x n)]
          (->
            [c : ($ Pick n p')]
            ($ y ($ proj' x n p' c f))))
    , proj = lam {proj1=x, proj2=y} n m c2 {proj1=f, proj2=g} =>
        { proj1 = `($ proj' x n m c2 f)
        , proj2 = lam c1 =>
          rewrite ($ proj-coh' x n m p' c1 c2 f);
          [ with z => `($ y z)
          , `($ g ($ Pick/compose n m p' c1 c2))
          ]
        }
    , proj-coh = lam {proj1=x, proj2=y} n m o c1 c2 {proj1=f, proj2=g} =>
        reduce at type left right;
        refine record/eq/tuple;
        [ `($ proj-coh' x n m o c1 c2 f)
        , refine fun/eq/lam;
          [ with c0 => rewrite ($ proj-coh' x n m o c1 c2 f) at type;
            [ with z => `($ y ($ proj' x o p' c0 z))
            , rewrite ($ proj-coh' x n o p' c0 ($ Pick/compose n m o c1 c2) f) at type;
              [ with z => `($ y z)
              , rewrite ($ Eq/inv ($ Pick n p')
                  ($ Pick/compose n m p' ($ Pick/compose m o p' c0 c1) c2)
                  ($ Pick/compose n o p' c0 ($ Pick/compose n m o c1 c2))
                  ($ Pick/compose/assoc n m o p' c0 c1 c2)) at type right;
                [ with z => `($ y ($ proj' x n p' z f))
                , with z => `($ g z)
                ]
              ]
            ]
          ]
        ]
    }
  ];
  auto
].

Thm SemiSimplicial : [
  (-> nat (U 1))
] by [
  lam n => `(! sst ($ MegaMutualDefs n))
].
