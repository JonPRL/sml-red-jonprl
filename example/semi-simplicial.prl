Thm Pick : [
  // pick #(first argument) from #(second argument)
  (-> nat nat (U 0))
] by [
  lam n => elim n;
  [ lam n => `record
  , with n'/ih n' => 
    lam m => elim m;
    [ `void
    , with m'/ih m' => 
      `(record
        [head : bool]
        [tail : (if [_] (U 0) head ($ n'/ih m') m'/ih)])
    ]
  ]
].

Thm Pick/zero/L : [
  (-> [n : nat] (= (U 0) ($ Pick zero n) record))
] by [
  lam n => auto
].

Thm Pick/succ/0/zero/1 : [
  (-> [n : nat] (= (U 0) ($ Pick (succ n) zero) void))
] by [
  lam n => auto
].

Thm Pick/succ/0/succ/1 : [
  (-> [n m : nat]
   (= (U 0)
    ($ Pick (succ n) (succ m))
    (record
     [head : bool]
     [tail : (if [_] (U 0) head ($ Pick n m) ($ Pick (succ n) m))])))
] by [
  lam n m => auto
].

Thm Pick/compose : [
  (->
   [a b c : nat]
   ($ Pick b c)
   ($ Pick a b)
   ($ Pick a c))
] by [
  lam a => elim a;
  [ lam b c p0 p1 => `tuple
  , with a'/ih a' =>
    lam b => elim b;
    [ lam c p0 p1 => elim p1
    , with b'/ih b' =>
      lam c => elim c;
      [ lam p0 => elim p0
      , with c'/ih c' =>
        lam p0 =>
        let {head = p0/h, tail = p0/t} = p0; elim p0/h;
        [ lam p1 =>
          let {head = p1/h, tail = p1/t} = p1; elim p1/h;
          [ { head = `tt
            , tail = `($ a'/ih b' c' p0/t p1/t)
            }
          , { head = `ff
            , tail = `($ b'/ih c' p0/t p1/t)
            }
          ]
        , lam p1 =>
          { head = `ff
          , tail = `($ c'/ih p0/t p1)
          }
        ]
      ]
    ]
  ]
].

Thm Pick/compose/zero/0 : [
  (->
   [b c : nat]
   [p0 : ($ Pick b c)]
   [p1 : ($ Pick 0 b)]
   (= ($ Pick 0 c) ($ Pick/compose 0 b c p0 p1) tuple))
] by [
  lam a b p0 p1 => auto
].

Thm Pick/compose/tt/4/0/tt/5/0 : [
  (->
   [a b c : nat]
   [p0/t : ($ Pick b c)]
   [p1/t : ($ Pick a b)]
   (=
    ($ Pick (succ a) (succ c))
    ($ Pick/compose (succ a) (succ b) (succ c)
       (tuple [head tt] [tail p0/t]) (tuple [head tt] [tail p1/t]))
    (tuple [head tt] [tail ($ Pick/compose a b c p0/t p1/t)])))
] by [
  lam a b c p0/t p1/t =>
    auto;
    unfold Pick; reduce; assumption
].

Thm Pick/compose/tt/4/0/ff/5/0 : [
  (->
   [a b c : nat]
   [p0/t : ($ Pick b c)]
   [p1/t : ($ Pick (succ a) b)]
   (=
    ($ Pick (succ a) (succ c))
    ($ Pick/compose (succ a) (succ b) (succ c)
       (tuple [head tt] [tail p0/t]) (tuple [head ff] [tail p1/t]))
    (tuple [head ff] [tail ($ Pick/compose (succ a) b c p0/t p1/t)])))
] by [
  lam a b c p0/t p1/t =>
    auto;
    unfold Pick; reduce; assumption
].

Thm Pick/compose/ff/4/0 : [
  (->
   [a b c : nat]
   [p0/t : ($ Pick (succ b) c)]
   [p1 : ($ Pick (succ a) (succ b))]
   (=
    ($ Pick (succ a) (succ c))
    ($ Pick/compose (succ a) (succ b) (succ c)
       (tuple [head ff] [tail p0/t]) p1)
    (tuple [head ff] [tail ($ Pick/compose (succ a) (succ b) c p0/t p1)])))
] by [
  lam a b c p0/t p1 =>
    auto; 
    unfold Pick; reduce; assumption
].

Thm Pick/compose/assoc : [
  (->
   [a b c d : nat]
   [p0 : ($ Pick c d)]
   [p1 : ($ Pick b c)]
   [p2 : ($ Pick a b)]
   (=
    ($ Pick a d)
    ($ Pick/compose a b d ($ Pick/compose b c d p0 p1) p2)
    ($ Pick/compose a c d p0 ($ Pick/compose a b c p1 p2))))
] by [
  lam a => elim a;
  [ lam b c d p0 p1 p2 => unfold Pick/compose; auto ]; // a = 0
  with a'/ind a' => lam b => elim b;
  [ lam c d p0 p1 p2 => elim p2 ]; // b = 0
  with b'/ind b' => lam c => elim c;
  [ lam d p0 p1 => elim p1 ]; // c = 0
  with c'/ind c' => lam d => elim d;
  [ lam p0 => elim p0 ]; // d = 0
  with d'/ind d' => lam p0 =>
  let {head = p0/h, tail = p0/t} = p0; elim p0/h;
  [ lam p1 => let {head = p1/h, tail = p1/t} = p1; elim p1/h;
    [ lam p2 => let {head = p2/h, tail = p2/t} = p2; elim p2/h;
      [ rewrite ($ Pick/compose/tt/4/0/tt/5/0 b' c' d' p0/t p1/t) at left;
        [ auto
        , with x => `($ Pick/compose (succ a') (succ b') (succ d') x (tuple [head tt] [tail p2/t]))
        , rewrite ($ Pick/compose/tt/4/0/tt/5/0 a' b' d' ($ Pick/compose b' c' d' p0/t p1/t) p2/t) at left;
          [ auto
          , with x => `x
          , rewrite ($ a'/ind b' c' d' p0/t p1/t p2/t) at left;
            [ auto
            , auto
            , with x => `(tuple [head tt] [tail x])
            , rewrite ($ Pick/compose/tt/4/0/tt/5/0 a' b' c' p1/t p2/t) at right;
              [ auto
              , with x => `($ Pick/compose (succ a') (succ c') (succ d') (tuple [head tt] [tail p0/t]) x)
              , rewrite ($ Pick/compose/tt/4/0/tt/5/0 a' c' d' p0/t ($ Pick/compose a' b' c' p1/t p2/t)) at right;
                [ auto
                , with x => `x
                ]
              ]
            ]
          ]
        ];
        auto
      , rewrite ($ Pick/compose/tt/4/0/tt/5/0 b' c' d' p0/t p1/t) at left;
        [ auto
        , with x => `($ Pick/compose (succ a') (succ b') (succ d') x (tuple [head ff] [tail p2/t]))
        , rewrite ($ Pick/compose/tt/4/0/ff/5/0 a' b' d' ($ Pick/compose b' c' d' p0/t p1/t) p2/t) at left;
          [ auto
          , with x => `x
          , rewrite ($ b'/ind c' d' p0/t p1/t p2/t) at left;
            [ auto
            , with x => `(tuple [head ff] [tail x])
            , rewrite ($ Pick/compose/tt/4/0/ff/5/0 a' b' c' p1/t p2/t) at right;
              [ auto
              , with x => `($ Pick/compose (succ a') (succ c') (succ d') (tuple [head tt] [tail p0/t]) x)
              , rewrite ($ Pick/compose/tt/4/0/ff/5/0 a' c' d' p0/t ($ Pick/compose (succ a') b' c' p1/t p2/t)) at right;
                [ auto
                , with x => `x
                ]
              ]
            ]
          ]
        ];
        auto
      ]
    , lam p2 => rewrite ($ Pick/compose/tt/4/0/ff/5/0 b' c' d' p0/t p1/t) at left;
      [ auto
      , with x => `($ Pick/compose (succ a') (succ b') (succ d') x p2)
      , rewrite ($ Pick/compose/ff/4/0 a' b' d' ($ Pick/compose (succ b') c' d' p0/t p1/t) p2) at left;
        [ auto
        , with x => `x
        , rewrite ($ c'/ind d' p0/t p1/t p2) at left;
          [ with x => `(tuple [head ff] [tail x])
          , rewrite ($ Pick/compose/ff/4/0 a' b' c' p1/t p2) at right;
            [ auto
            , with x => `($ Pick/compose (succ a') (succ c') (succ d') (tuple [head tt] [tail p0/t]) x)
            , rewrite ($ Pick/compose/tt/4/0/ff/5/0 a' c' d' p0/t ($ Pick/compose (succ a') (succ b') c' p1/t p2)) at right;
              [ auto
              , with x => `x
              ]
            ]
          ]
        ]
      ];
      auto
    ]
  , lam p1 p2 => rewrite ($ Pick/compose/ff/4/0 b' c' d' p0/t p1) at left;
    [ auto
    , with x => `($ Pick/compose (succ a') (succ b') (succ d') x p2)
    , rewrite ($ Pick/compose/ff/4/0 a' b' d' ($ Pick/compose (succ b') (succ c') d' p0/t p1) p2) at left;
      [ auto
      , with x => `x
      , rewrite ($ Pick/compose/ff/4/0 a' c' d' p0/t ($ Pick/compose (succ a') (succ b') (succ c') p1 p2)) at right;
        [ auto
        , with x => `x
        , rewrite ($ d'/ind p0/t p1 p2) at left;
          [ with x => `(tuple [head ff] [tail x])
          , auto
          ]
        ]
      ]
    ];
    auto
  ]
].

Thm Plus : [
  (-> nat nat nat)
] by [
  lam n => elim n;
  [ lam m => `m
  , with n'/ind => lam m => `(succ ($ n'/ind m))
  ]
].

Thm Plus/succ/0 : [
  (-> [n m : nat]
    (= nat ($ Plus (succ n) m) (succ ($ Plus n m))))
] by [
  lam n m => unfold Plus; auto
].

// Maybe this is useless...?
Thm Plus/assoc : [
  (-> [n m o : nat]
    (= nat ($ Plus ($ Plus n m) o) ($ Plus n ($ Plus m o))))
] by [
  lam n m o => elim n;
    [ unfold Plus; auto
    , with n'/ind n' =>
        rewrite ($ Plus/succ/0 n' m) at left;
        [ with x => `($ Plus x o)
        , rewrite ($ Plus/succ/0 ($ Plus n' m) o) at left;
          [ with x => `x
          , rewrite ($ Plus/succ/0 n' ($ Plus m o)) at right;
            [ with x => `x
            , rewrite n'/ind at left;
              [ with x => `(succ x) ]
            ]
          ]
        ]
    ];
    auto
].
