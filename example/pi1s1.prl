Thm IntSucc : [
  (-> int int)
] by [
  lam i => `(int-rec i 1 [n _] (succ (succ n)) 0 [n _] (negsucc n));
    refine int/eq/int-rec; [ `int ]; auto
].

Thm IntPred : [
  (-> int int)
] by [
  lam i => `(int-rec i -1 [n _] (nat-rec n 0 [n _] (succ n)) -2 [n _] (negsucc (succ (succ n))));
    refine int/eq/int-rec; [ `int ]; auto;
    refine nat/eq/nat-rec; [ `int ]; auto
].

Thm IntSuccIntPred : [
  (-> [i : int] (= int ($ IntSucc ($ IntPred i)) i))
] by [
  lam i => fresh n -> elim i;
    [ auto
    , elim n; auto
    , auto
    , auto
    ]
].

Thm IntPredIntSucc : [
  (-> [i : int] (= int ($ IntPred ($ IntSucc i)) i))
] by [
  lam i => fresh n -> elim i;
    [ auto
    , auto
    , auto
    , elim n; auto
    ]
].

Def HasAllPathsTo (#C,#c) = [(-> [c' : #C] (path [_] #C c' #c))].

Def IsContr (#C) = [(* [c : #C] (HasAllPathsTo #C c))].

Def Fiber (#A,#B,#f,#b) = [(* [a : #A] (path [_] #B ($ #f a) #b))].

Def IsEquiv (#A,#B,#f) = [(-> [b : #B] (IsContr (Fiber #A #B #f b)))].

Def Equiv (#A,#B) = [(* [f : (-> #A #B)] (IsEquiv #A #B f))].

Thm IntSuccIsEquiv : [
  (IsEquiv int int IntSucc)
] by [
  lam i =>
    claim eq : [(= int ($ IntSucc ($ IntPred i)) i)] by [use IntSuccIntPred [`i]];
    unfold IntSucc IntPred in eq; reduce at left in eq;
    {
      {use IntPred [`i], abs _ => `i}
    , lam {i',p'} =>
        claim eq0 : [(= int i ($ IntSucc i'))] by [`(coe 1~>0 [x] (= int i (@ p' x)) ax)];
        claim eq1 : [(= int ($ IntPred i) i')] by [
          fresh i'' ->
            rewrite eq0;
            [`(= int ($ IntPred i'') i'), `($ IntPredIntSucc i')];
            auto
        ];

        (abs x =>
          {`($ IntPred i), abs y => `(hcom 1~>y int i [x=0 [y] (@ p' y)] [x=1 [_] i])});

        auto; unfold IntPred in eq1; reduce at left in eq1; auto
    }
].

Thm IntSuccEquiv : [
  (Equiv int int)
] by [
  {`IntSucc, `IntSuccIsEquiv}
].

Thm IntSuccPath : [
  (path [_] (U 0 kan) int int)
] by [
  abs x => `(V x int int IntSuccEquiv)
].

Thm S1UnivCover : [
  (-> S1 (U 0 kan))
] by [
  lam x => exact (S1-rec [_] (U 0 kan) x int [x] (@ IntSuccPath x)); refine s1/eq/s1-rec; auto
].

Thm Loop : [
  (path [_] S1 base base)
] by [
  abs i => `(loop i)
].

Thm S1LoopToInt : [
  (-> (path [_] S1 base base) int)
] by [
  lam l => `(coe 0~>1 [x] ($ S1UnivCover (@ l x)) 0);
    claim eq : [(= S1 (@ l 1) base)] by [auto];
    refine coe/eq; auto;
    [ fresh x -> rewrite eq at type; [`($ S1UnivCover x)]; auto
    , fresh x -> rewrite eq at left; [`($ S1UnivCover x)]; auto
    ]
].

Thm S1LoopConcat : [
  (->
   (path [_] S1 base base)
   (path [_] S1 base base)
   (path [_] S1 base base))
] by [
  lam p q => abs x => `(hcom 0~>1 S1 (@ p x) [x=0 [_] base] [x=1 [y] (@ q y)])
].

Thm S1LoopInv : [
  (->
   (path [_] S1 base base)
   (path [_] S1 base base))
] by [
  lam p => abs x => `(hcom 0~>1 S1 base [x=0 [y] (@ p y)] [x=1 [_] base])
].

Thm IntToS1Loop : [
  (-> int (path [_] S1 base base))
] by [
  lam i => fresh n ih -> elim i;
    [ abs _ => `base
    , `($ S1LoopConcat Loop ih)
    , `($ S1LoopInv Loop)
    , `($ S1LoopConcat ($ S1LoopInv Loop) ih)
    ]
].

Thm Test0 : [
  (= int ($ S1LoopToInt ($ IntToS1Loop 3)) 3)
] by [
  unfold IntToS1Loop Loop; auto
].

Thm Test1 : [
  (= int ($ S1LoopToInt ($ IntToS1Loop -3)) -3)
] by [
  unfold IntToS1Loop S1LoopInv Loop; auto
].
