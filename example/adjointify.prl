define IsContr (#C) = (* [c : #C] (-> [c' : #C] (path [_] #C c' c))).

define Fiber (#A,#B,#f,#b) = (* [a : #A] (path [_] #B ($ #f a) #b)).

define IsEquiv (#A,#B,#f) = (-> [b : #B] (IsContr (Fiber #A #B #f b))).

define Equiv (#A,#B) = (* [f : (-> #A #B)] (IsEquiv #A #B f)).

define Iso(#A, #B) =
  (record
   [f : (-> #A #B)]
   [g : (-> #B #A)]
   [fg : (-> [b : #B] (path [_] #B ($ f ($ g b)) b))]
   [gf : (-> [a : #A] (path [_] #A ($ g ($ f a)) a))]).

theorem LemIso(#l:lvl) :
  (->
   [ty/a : (U #l kan)]
   [ty/b : (U #l kan)]
   [iso : (Iso ty/a ty/b)]
   [b : ty/b]
   [f0 f1 : (Fiber ty/a ty/b (!f iso) b)]
   (path [_] (Fiber ty/a ty/b (!f iso) b) f0 f1))
by {
  lam ty/a ty/b {f=f,g=g,fg=fg,gf=gf} b {x0,p0} {x1,p1} =>
  claim sq0 : (path [i] (path [j] ty/a ($ g (@ p0 i)) 
                                       (hcom 0~>1 ty/a ($ g (@ p0 i))
                                          [i=0 [j] (@ ($ gf x0) j)]
                                          [i=1 [_] ($ g b)]))
                 (abs [_] ($ g b)) ($ gf x0)) by {
    abs i j =>
    `(hcom 0~>j ty/a ($ g (@ p0 i))
        [i=0 [j] (@ ($ gf x0) j)]
        [i=1 [_] ($ g b)])
  };
  claim sq0i1 : (path [i] ty/a x0 ($ g b)) by { abs i => `(@ sq0 i 1) };
  claim sq1 : (path [i] (path [j] ty/a ($ g (@ p1 i))
                                       (hcom 0~>1 ty/a ($ g (@ p1 i))
                                          [i=0 [j] (@ ($ gf x1) j)]
                                          [i=1 [_] ($ g b)]))
                 (abs [_] ($ g b)) ($ gf x1)) by {
    abs i j =>
    `(hcom 0~>j ty/a ($ g (@ p1 i))
        [i=0 [j] (@ ($ gf x1) j)]
        [i=1 [_] ($ g b)])
  };
  claim sq1i1 : (path [i] ty/a x1 ($ g b)) by { abs i => `(@ sq1 i 1) };
  claim sq2 : (path [i] (path [j] ty/a (hcom 1~>0 ty/a ($ g b)
                                          [i=0 [j] (@ sq0i1 j)]
                                          [i=1 [j] (@ sq1i1 j)])
                                       ($ g b))
                 sq0i1 sq1i1) by {
    abs i j =>
    `(hcom 1~>j ty/a ($ g b)
        [i=0 [j] (@ sq0i1 j)]
        [i=1 [j] (@ sq1i1 j)])
  };
  claim sq2i1 : (path [i] ty/a x0 x1) by { abs i => `(@ sq2 i 0) };
  claim goalsq : (path [i] (path [j] ty/b ($ f (@ sq2i1 i)) b)
                       p0
                       p1) by {
    id
  };
  abs i =>
  {`(@ sq2i1 i), id};
  abs j =>
  `(@ goalsq i j)
}.

theorem Adjointify(#l:lvl) :
  (->
   [ty/a : (U #l kan)]
   [ty/b : (U #l kan)]
   (Iso ty/a ty/b)
   (Equiv ty/a ty/b))
by {
  lam ty/a ty/b {f=f,g=g,fg=fg,gf=gf} =>
  {use f, id};
  lam b =>
  {{`($ g b), `($ fg b)}, id};
  lam fib =>
  use (LemIso #l)
    [`ty/a,
     `ty/b,
     `(tuple [f f] [g g] [fg fg] [gf gf]),
     `b,
     `fib,
     {`($ g b), `($ fg b)}]
}.
