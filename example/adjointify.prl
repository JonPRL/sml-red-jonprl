define IsContr (#C) = (* [c : #C] (-> [c' : #C] (path [_] #C c' c))).

define Fiber (#A,#B,#f,#b) = (* [a : #A] (path [_] #B ($ #f a) #b)).

define IsEquiv (#A,#B,#f) = (-> [b : #B] (IsContr (Fiber #A #B #f b))).

define Equiv (#A,#B) = (* [f : (-> #A #B)] (IsEquiv #A #B f)).

define Iso(#A, #B) =
  (record
   [f : (-> #A #B)]
   [g : (-> #B #A)]
   [fg : (-> [b : #B] (path [_] #B ($ f ($ g b)) b))]
   [gf : (-> [a : #A] (path [_] #A ($ g ($ f a)) a))]).

// not needed?
theorem WhiskerLeft(#l:lvl) :
  (->
   [ty : (U #l kan)]
   [a b c d : ty]
   [pab : (path [_] ty a b)]
   [pac : (path [_] ty a c)]
   [pbd : (path [_] ty b d)]
   [pcd : (path [_] ty c d)]
   [sq : (path [i] (path [j] ty (@ pab i) (@ pcd i)) pac pbd)]
   [pac' : (path [_] ty a c)]
   [h : (path [_] (path [_] ty a c) pac' pac)]
   (path [i] (path [j] ty (@ pab i) (@ pcd i)) pac' pbd))
by {
  lam ty a b c d pab pac pbd pcd sq pac' h =>
  (abs i j =>
  `(hcom 1~>0 ty (@ sq i j)
     [i=0 [k] (@ h k j)]
     [i=1 [_] (@ pbd j)]
     [j=0 [_] (@ pab i)]
     [j=1 [_] (@ pcd i)]))
}.

theorem Connection/Or/Weak(#l:lvl) :
  (->
   [ty : (U #l hcom)]
   [a b : ty]
   [p : (path [_] ty a b)]
   (path [i] (path [_] ty (@ p i) b) p (abs [_] b)))
by {
  lam ty a b p =>
   abs i j =>
     `(hcom 1~>0 ty b
       [i=0 [k] (hcom 0~>j ty (@ p k) [k=0 [w] (@ p w)] [k=1 [_] b])]
       [i=1 [k] (hcom 0~>1 ty (@ p k) [k=0 [w] (@ p w)] [k=1 [_] b])]
       [j=0 [k] (hcom 0~>i ty (@ p k) [k=0 [w] (@ p w)] [k=1 [_] b])]
       [j=1 [k] (hcom 0~>1 ty (@ p k) [k=0 [w] (@ p w)] [k=1 [_] b])])
}.

theorem Adjointify(#l:lvl) :
  (->
   [ty/a : (U #l kan)]
   [ty/b : (U #l kan)]
   (Iso ty/a ty/b)
   (Equiv ty/a ty/b))
by {
  lam ty/a ty/b {f=f,g=g,fg=fg,gf=gf} =>
  {use f, id};
  lam b =>
  {{`($ g b), `($ fg b)}, id};
  lam {a,fab} =>
  claim back : (path [j] (path [k] ty/b
                               (hcom 1~>0 ty/b b
                                  [j=0 [k] (@ ($ fg (@ fab k)) k)]
                                  [j=1 [k] (@ fab k)])
                               b)
                     (abs [k] (@ ($ fg (@ fab k)) k))
                     fab) by {
    abs j k =>
    `(hcom 1~>k ty/b b [j=0 [k] (@ ($ fg (@ fab k)) k)] [j=1 [k] (@ fab k)])
  };
  claim top : (path [i] (path [k] ty/b ($ f ($ g (@ fab i))) b)
                    (abs [k] (@ ($ fg (@ fab k)) k))
                    ($ fg b)) by {
    // fg (fab @ k \/ i) @ k
    abs i k =>
    `(@ ($ fg (@ ($ (Connection/Or/Weak #l) ty/b ($ f a) b fab) i k)) k)
  };
  claim back' : (path [j] (path [k] ty/b ($ f a) b)
                      (abs [k] (@ ($ fg (@ fab k)) k))
                      fab) by {
    id
  };
  claim foo : (path [i] (path [j] ty/b
                              ($ f ($ g (@ fab i)))
                              ($ f (hcom 0~>1 ty/a ($ g (@ fab i))
                                      [i=0 [j] (hcom 0~>1 ty/a ($ g (@ back j 0))
                                                  [j=0 [k] (@ ($ gf ($ g ($ f a))) k)]
                                                  [j=1 [k] (@ ($ gf a) k)])]
                                      [i=1 [_] ($ g b)])))
                        ($ f a) // ??
                        ($ fg b)) by {
    id
  };
  (abs i =>
  {`(hcom 0~>1 ty/a ($ g (@ fab i))
      [i=0 [j] (hcom 0~>1 ty/a ($ g (@ back j 0))
                  [j=0 [k] (@ ($ gf ($ g ($ f a))) k)]
                  [j=1 [k] (@ ($ gf a) k)])]
      [i=1 [_] ($ g b)]),
   abs k =>
   `(hcom 0~>1 ty/b (@ top i k)
      [k=0 [j] (@ foo i j)]
               //($ f (hcom 0~>1 ty/a ($ g (@ fab i))
               //        [i=0 [j] (hcom 0~>1 ty/a ($ g (@ back j 0))
               //                    [j=0 [k] (@ ($ gf ($ g ($ f a))) k)]
               //                    [j=1 [k] (@ ($ gf a) k)])]
               //        [i=1 [_] ($ g b)]))]
      [k=1 [_] b]
      [i=0 [j] (@ back' j k)]
      [i=1 [_] (@ ($ fg b) k)])
  }); auto; ?
}.
