define IsContr (#C) = (* [c : #C] (-> [c' : #C] (path [_] #C c' c))).

define Fiber (#A,#B,#f,#b) = (* [a : #A] (path [_] #B ($ #f a) #b)).

define IsEquiv (#A,#B,#f) = (-> [b : #B] (IsContr (Fiber #A #B #f b))).

define Equiv (#A,#B) = (* [f : (-> #A #B)] (IsEquiv #A #B f)).

define Iso(#A, #B) =
  (record
   [f : (-> #A #B)]
   [g : (-> #B #A)]
   [fg : (-> [b : #B] (path [_] #B ($ f ($ g b)) b))]
   [gf : (-> [a : #A] (path [_] #A ($ g ($ f a)) a))]).

define Rem/Sq(#A,#g,#gf,#b,#x,#p,#i:dim,#j:dim) =
  (hcom 0~>#j #A ($ #g (@ #p #i))
     [#i=0 [k] (@ ($ #gf #x) k)]
     [#i=1 [_] ($ #g #b)]).

theorem LemIso(#l:lvl) :
  (->
   [ty/a : (U #l kan)]
   [ty/b : (U #l kan)]
   [iso : (Iso ty/a ty/b)]
   [b : ty/b]
   [f0 f1 : (Fiber ty/a ty/b (!f iso) b)]
   (path [_] (Fiber ty/a ty/b (!f iso) b) f0 f1))
by {
  lam ty/a ty/b {f=f,g=g,fg=fg,gf=gf} b {x0,p0} {x1,p1} =>
  claim sq0 : (path [i] (path [j] ty/a ($ g (@ p0 i))
                                       (Rem/Sq ty/a g gf b x0 p0 i 1))
                    ($ gf x0) (abs [_] ($ g b))) by {
    abs i j => `(Rem/Sq ty/a g gf b x0 p0 i j)
  };
  claim sq1 : (path [i] (path [j] ty/a ($ g (@ p1 i))
                                       (Rem/Sq ty/a g gf b x1 p1 i 1))
                    ($ gf x1) (abs [_] ($ g b))) by {
    abs i j => `(Rem/Sq ty/a g gf b x1 p1 i j)
  };
  claim sq2 : (path [i] (path [j] ty/a (hcom 1~>0 ty/a ($ g b)
                                          [i=0 [j] (@ sq0 j 1)]
                                          [i=1 [j] (@ sq1 j 1)])
                                       ($ g b))
                    (abs [i] (@ sq0 i 1))
                    (abs [i] (@ sq1 i 1))) by {
    abs i j =>
    `(hcom 1~>j ty/a ($ g b)
        [i=0 [j] (@ sq0 j 1)]
        [i=1 [j] (@ sq1 j 1)])
  };
  claim sq2i1 : (path [i] ty/a x0 x1) by { abs i => `(@ sq2 i 0) };
  claim goalsq : (path [i] (path [j] ty/b ($ f (@ sq2i1 i)) b)
                       p0
                       p1) by {
    id
  };
  abs i =>
  {`(@ sq2i1 i), id};
  abs j =>
  `(@ goalsq i j)
}.

theorem Adjointify(#l:lvl) :
  (->
   [ty/a : (U #l kan)]
   [ty/b : (U #l kan)]
   (Iso ty/a ty/b)
   (Equiv ty/a ty/b))
by {
  lam ty/a ty/b {f=f,g=g,fg=fg,gf=gf} =>
  {use f, id};
  lam b =>
  {{`($ g b), `($ fg b)}, id};
  lam fib =>
  use (LemIso #l)
    [`ty/a,
     `ty/b,
     `(tuple [f f] [g g] [fg fg] [gf gf]),
     `b,
     `fib,
     {`($ g b), `($ fg b)}]
}.
