\chapter{Nominal LCF: a language for tactics}

In a sequent calculus, left rules add hypotheses to the context; for instance,
consider the left rule for positive conjunctions:
\[
  \infer[{\otimes_L^{\IMode{x},\OMode{y},\OMode{z}}}]{
    \IMode{H,x:A\otimes B}\gg\IMode{C}
  }{
    \IMode{H,x:A\otimes B,y:A,z:B}\gg\IMode{
      \IMode{\Subst{\Pair{y}{z}}{x}{C}}
    }
  }
\]
%

From a proof refinement perspective (see~\cite{constable:1986}), such a rule is
typically manifested as an ML tactic $\mathtt{\otimes_L}[x,y,z]$ which takes
three names as parameters: the target hypothesis $\IMode{x}$, and the names to
use for the new hypotheses $\OMode{y},\OMode{z}$. However, whilst the identity
of the name $x$ is essential to the meaning of the tactic, the names supplied
for the generated hypotheses can be freshly renamed with impunity.

Indeed, in a proof term assignment for this sequent calculus, the corresponding
elimination form would \emph{bind} variables $x,y$ rather than take them as
parameters. However, in the standard LCF tactic paradigm, it is not possible to
reproduce this structure, because the sequencing of rules is mediated by the
general purpose $\mathtt{THEN}$ tactical, which has no knowledge of names or
binding.

We will design a language for tactics called \textbf{Nominal LCF} which
supports a distinction between names bound and names taken as parameters, and
then show how it can be elaborated into standard LCF.

\section{The LCF Tactic Language}
\newcommand\MLTypeDecl[1]{\mathtt{type}\ #1}
\newcommand\PartialFun[2]{#1\rightharpoonup #2}
\newcommand\LCFJudgment{\mathit{judgment}}
\newcommand\LCFEvidence{\mathit{evidence}}
\newcommand\LCFState{\mathit{state}}
\newcommand\LCFStateApply[2]{#1\star #2}
\newcommand\LCFTactic{\mathit{tactic}}
\newcommand\MLList[1]{#1\;\mathit{list}}
\newcommand\MLAtom{\mathbb{A}}
\newcommand\MLNat{\mathbb{N}}
\newcommand\MLStream[1]{{#1}^{\MLNat}}
\newcommand\MLPair[2]{\left(#1, #2\right)}
\newcommand\LCFAtomicTactic{\mathit{atactic}}
\newcommand\StreamTake[2]{\bar{#1}[#2]}
\newcommand\StreamChop[2]{[#2]\bar{#1}}
\newcommand\MLListSplit[2]{\mathsf{split}(#1, #2)}
\newcommand\LCFStateSplit[3]{\mathsf{split}_{#1}^{#2}(#3)}
\DeclarePairedDelimiter{\MLLength}{\lVert}{\rVert}


The essence of the LCF tactic system is captured in the following (idealized)
ML signature:

\[
  \begin{array}{lcl}
    \MLTypeDecl{\LCFJudgment}\\
    \MLTypeDecl{\LCFEvidence}\\
    \MLTypeDecl{\LCFState} &= &\MLList{\LCFJudgment} \otimes (\PartialFun{\MLList{\LCFEvidence}}{\LCFEvidence})\\
    \MLTypeDecl{\LCFTactic} &= &\PartialFun{\LCFJudgment}{\LCFState}
  \end{array}
\]

In other words, a tactic is a partial function that takes a goal to its
subgoals, and specifies how to transform the evidence of its subgoals into the
evidence for the main goal. In the case of the sequence calculus we were
considering, \verb!judgment! would be a type of sequents. We will write
$\Dom{P}$ for the list of subgoals $\pi_1(P)$ to a proof state
$\Member{P}{\LCFState}$, $\MLLength{P}$ for the length of $\Dom{P}$, and
$\LCFStateApply{P}{\vec{x}}$ for the application of the hypothetical evidence
$\pi_2(P)$ to the concrete evidence $\Member{\vec{x}}{\MLList{\LCFEvidence}}$.

Now, in general a tactic may need to consume names from a \emph{name store},
which is an infinite stream of \emph{atoms} or \emph{symbols}:

\[
  \begin{array}{lcl}
    \MLTypeDecl{\MLAtom}\\
    \MLTypeDecl{\LCFAtomicTactic} &= &\MLStream{\MLAtom} \to \LCFTactic
  \end{array}
\]

\newcommand\KleeneEq[2]{\IMode{#1}\approx \IMode{#2}}
\newcommand\ModC[2]{\mathsf{M}(#1,#2)}

\subsection{Atomic tactics and their continuity}

Left sequent rules can be coded as so-called \emph{atomic tactics}, tactics
which consume a stream of names. In fact, every such tactic is
\emph{continuous} in a specific sense. For an atomic sequence
$\Member{\alpha}{\MLStream{\MLAtom}}$ and a natural number
$\Member{n}{\MLNat}$, let $\StreamTake{\alpha}{n}$ be the initial segment of
$\alpha$ of length $n$; let $\StreamChop{\alpha}{n}$ be infinite suffix of
$\alpha$ got by chopping off the initial prefix $\StreamTake{\alpha}{n}$. Let
$\KleeneEq{M}{N}$ be \emph{observational equivalence}: $M$ and $N$ evaluate to
equal values, or they both diverge.

Then, for any atomic tactic $T$ and judgment $J$, we can calculate a
modulus of continuity:
\begin{equation}
  \forall \Member{\alpha}{\MLStream{\MLAtom}}.
  \exists \OMode{n}\in\IMode{\MLNat}.
  \forall \Member{\beta}{\MLStream{\MLAtom}}.
    \IsEq{\bar{\alpha}(n)}{\bar{\beta}(n)}\implies \KleeneEq{T(\alpha,J)}{T(\beta,J)}
  \tag{continuity}
\end{equation}

This calculation can be realized computationally in our metalanguage in a
number of ways, but for our purposes it suffices to remark that it is a fact
concerning all computable stream processors. Let
$\Member{\ModC{T}{J}}{\MLNat}$ calculate the modulus of continuity
for an atomic tactic $\Member{T}{\LCFAtomicTactic}$ at goal $J$.

\section{Nominal LCF}

\subsection{Static Semantics}

\newcommand\SortATac{\mathtt{atac}}
\newcommand\SortBTac{\mathtt{btac}}
\newcommand\SortTac{\mathtt{tac}}
\newcommand\SortMTac{\mathtt{mtac}}
\newcommand\SortHyp{\mathtt{hyp}}

We will define the \textbf{Nominal LCF} language by specifying an abt signature
for it; at its heart is decomposition of the various sequencing tacticals
$\mathtt{THEN}$, $\mathtt{THENL}$, etc.\ of LCF into a single sequencing
tactical combined a separate notion of \emph{multi-tactic}.

First, we define sorts for tactics, atomic tactics, binding tactics and multi-tactics
respectively:
\begin{gather*}
  \infer{
    \IsSort{\SortTac}
  }{}
  \qquad
  \infer{
    \IsSort{\SortATac}
  }{}
  \qquad
  \infer{
    \IsSort{\SortBTac}
  }{}
  \qquad
  \infer{
    \IsSort{\SortMTac}
  }{}
\end{gather*}

We also provide a sort to classify hypotheses:
\[
  \infer{
    \IsSort{\SortHyp}
  }{
  }
\]

Now, we'll define the operators of \textbf{Nominal LCF}; note that the
operators of sort $\SortATac$ are arbitrary and are provided only for the sake
of illustration. We will consider the definition of \textbf{Nominal LCF} as
over some signature $\Sigma$ of atomic tactics.

\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{id}}{
      \MkArity{}{\SortATac}
    }
  }{
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon}{\mathtt{fail}}{
      \MkArity{}{\SortATac}
    }
  }{
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon,a:\SortHyp}{\mathtt{elim}[a]}{
      \MkArity{}{\SortATac}
    }
  }{
  }
\]

\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{seq}_n}{
      \MkArity{
        \MkValence{}{}{\SortBTac},
        \MkValence{\SortHyp^n}{}{\SortMTac}
      }{\SortTac}
    }
  }{
    \Member{n}{\MLNat}
  }
\]

\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{smash}}{
      \MkArity{
        \MkValence{}{}{\SortATac},
        \MkValence{}{}{\SortATac}
      }{\SortBTac}
    }
  }{
    \Member{n}{\MLNat}
  }
\]

\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{all}}{
      \MkArity{
        \MkValence{}{}{\SortTac}
      }{\SortMTac}
    }
  }{
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon}{\mathtt{each}_n}{
      \MkArity{
        \MkValence{}{}{\SortTac}^n
      }{\SortMTac}
    }
  }{
    \Member{n}{\MLNat}
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon}{\mathtt{some}_i}{
      \MkArity{
        \MkValence{}{}{\SortTac}
      }{\SortMTac}
    }
  }{
    \Member{i}{\MLNat}
  }
\]

\newcommand\TacSmash[2]{#1\supsetplus #2}
\newcommand\TacEach[1]{\llparenthesis #1\rrparenthesis}
\newcommand\TacSeq[3]{#2\leftarrow #1; #3}

For the sake of clarity, we introduce the following notational abbreviations
for tactic expressions:
\begin{align*}
  \ADefine{
    t_1;t_2
  }{
    \App{\mathtt{seq}_0}{\MkAbs{}{}{t_1};\MkAbs{}{}{t_2}}
  }\\
  \ADefine{
    \TacSeq{t_1}{a_0,\dots,a_n}{t_2}
  }{
  \App{\mathtt{seq}_n}{\MkAbs{}{}{t_1};\MkAbs{a_0,\dots,a_n}{}{t_2}}
  }\\
  \ADefine{
    \TacSmash{t_1}{t_2}
  }{
    \App{\mathtt{smash}}{\MkAbs{}{}{t_1};\MkAbs{}{}{t_n}}
  }\\
  \ADefine{
    \Box t
  }{
    \App{\mathtt{all}}{\MkAbs{}{}{t}}
  }\\
  \ADefine{
    \TacEach{t_1,\dots,t_n}
  }{
    \App{\mathtt{each}_n}{\MkAbs{}{}{t_1};\dots;\MkAbs{}{}{t_n}}
  }\\
  \ADefine{
    \Diamond_i t
  }{
    \App{\mathtt{some}_i}{\MkAbs{}{}{t}}
  }\\
\end{align*}

\subsection{Dynamic Semantics}
\newcommand\LCFElab[5]{%
  \mathcal{M}\models_\IMode{\rho}
  \IMode{#1}\parallel\IMode{#2}\vdash%
  \IMode{#3}\;@\;\IMode{#4}\Longrightarrow\OMode{#5}%
}

\newcommand\LCFElabSt[7]{%
  \mathcal{M}\models_\IMode{\rho}%
  % \IMode{#1}\parallel\IMode{#2}\vdash%
  \IMode{#3}\;@\; \IMode{#4}\xRightarrow{\;\OMode{#7}\;}\OMode{#5}%
  \ll\IMode{#6}
}

\newcommand\LCFElabStVerbose[7]{%
  \mathcal{M}\models_\IMode{\rho}%
  \IMode{#1}\parallel\IMode{#2}\vdash%
  \IMode{#3}\;@\; \IMode{#4}\xRightarrow{\;\OMode{#7}\;}\OMode{#5}%
  \ll\IMode{#6}
}


For a signature of atomic tactics $\Sigma$, we will define a $\Sigma$-model
$\mathcal{M}$ to be an interpretation of each atomic tactic
$\Member{t}{\Sigma}$ into some
$\Member{\SemBrackets{t}_\mathcal{M}}{\LCFAtomicTactic}$; additionally, the
model shall come equipped with a free choice sequence of atoms
$\Member{\alpha_\mathcal{M}}{\MLStream{\MLAtom}}$, such that each neighborhood
$\IMode{\vec{u}}\ni\IMode{\alpha_\mathcal{M}}$ shall contain only distinct
atoms.\footnote{This is an example of a \emph{spread law}
(see~\cite{brouwer:1981}).} Then, we can interpret all of \textbf{Nominal LCF}
into $\mathcal{M}$, by defining an elaboration judgment
$\LCFElab{\Upsilon}{\Gamma}{t}{J}{P}$ with
$\Member{J}{\LCFJudgment}$ and
$\Member{P}{\LCFState}$,
such that $\Member{\rho(x)}{\LCFAtomicTactic}$ for each
$\Member{x:\SortATac}{\Gamma}$.

First, we define the elaboration uniformly by appealing to an auxiliary judgment:
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{t}{J}{P}
  }{
    \LCFElabStVerbose{\Upsilon}{\Gamma}{t}{J}{P}{\alpha_\mathcal{M}}{\mu}
  }
\]

This auxiliary form of judgment is made with respect to a free choice sequence
of names $\alpha$, and synthesizes the modulus of continuity $\mu$ of
the tactic under consideration.  When it leads to no ambiguity, we will write
$\LCFElabSt{\Upsilon}{\Gamma}{t}{J}{P}{\alpha}{\mu}$ instead of the
more verbose
$\LCFElabStVerbose{\Upsilon}{\Gamma}{t}{J}{P}{\alpha}{\mu}$; we will
explain this form of judgment for $t$ of sorts $\SortATac$, $\SortBTac$, and
$\SortTac$. To start with, we will give the elaboration rules for constants
(atomic tactics) and variables denoting atomic tactics:

\[
  \infer{
    \LCFElabSt{\Upsilon}{\Gamma}{t}{J}{
      \SemBrackets{t}_\mathcal{M}(\alpha,J)
    }{\alpha}{\mu}
  }{
    \Match{
      \ModC{\SemBrackets{t}_\mathcal{M}}{J}(\alpha)
    }{
      \mu
    }
  }
  \qquad
  \infer{
    \LCFElabSt{\Upsilon}{\Gamma}{x}{J}{
      \rho(x)(\alpha,J)
    }{\alpha}{\mu}
  }{
    \Match{
      \ModC{\rho(x)}{J}(\alpha)
    }{
      \mu
    }
  }
\]

\newcommand\LCFMergeProofState[3]{%
  \bigtriangledown_{#2\in #1} #3%
}

Let $\MLListSplit{\vec{x}}{\vec{n}}$ be the operation that splits the list
$\vec{x}$ into a list sublists of $\vec{x}$ of length $n$ for each
$\Member{n}{\vec{n}}$. Then, for a proof state $\Member{P}{\LCFState}$ and a
vector of proof states $\HypJ{\Member{Q_J}{\LCFState}}{\Member{J}{\Dom{P}}}$,
we can form a new proof state collapses the two layers of subgoals into one, as follows:
\begin{align*}
  \ADefine{
    \LCFStateSplit{J\in\Dom{P}}{Q_J}{\vec{x}}
  }{
    \MLListSplit{
      \vec{x}
    }{
      \left[
        \MLLength{Q_J}
        \mid
        J\in\Dom{P}
      \right]
    }
  }\\
  \ADefine{
    \LCFMergeProofState{\Dom{P}}{J}{Q_J}
  }{
    \MLPair{
      \bigoplus_{J\in\Dom{P}}\Dom{Q_J}
    }{
      \lambda \vec{x}.\
      \LCFStateApply{P}{
        \left[
          \LCFStateApply{Q_J}{\vec{y}}
          \mid
          \MLPair{
            \vec{y}
          }{
            J
          }
          \in
          \MLPair{
            \LCFStateSplit{J\in\Dom{P}}{Q_J}{\vec{x}}
          }{
            \Dom{P}
          }
        \right]
      }
    }
  }
\end{align*}


The rule for the \emph{smash} tactical $\TacSmash{t_1}{t_2}$ exploits the
continuity of atomic tactics to divide up the name store $\alpha$
between $t_1$ and $t_2$:
\[
  \infer{
    \LCFElabSt{\Upsilon}{\Gamma}{\TacSmash{t_1}{t_2}}{J}{
      \LCFMergeProofState{\Dom{P}}{K}{Q_K}
    }{\alpha}{\mu'}
  }{
    \begin{array}{l}
      \LCFElabSt{\Upsilon}{\Gamma}{t_1}{J}{P}{\alpha}{\mu}\\
      \HypJ{
        \LCFElabSt{\Upsilon}{\Gamma}{t_2}{K}{Q_K}{\StreamChop{\alpha}{\mu}}{\mu_{K}}
      }{
        \Member{K}{\Dom{P}}
      }
    \end{array} &
    \Match{
      \mu + \bigsqcup_{K\in\Dom{P}}\mu_{K}
    }{\mu'}
  }
\]


Next, we define the behavior of the sequencing tactical in a single rule by
exploiting an auxiliary form of judgment concerning the action of
multi-tactics on proof states,
$\LCFElabSt{\Upsilon}{\Gamma}{t}{P}{Q}{\alpha}{\mu}$ (with
$\Member{P,Q}{\LCFState}$):
%
 \[
   \infer{
     \LCFElabSt{\Upsilon}{\Gamma}{
       \TacSeq{t_1}{\vec{u}}{t_2}
     }{J}{Q}{\alpha}{\mu_1+\mu_2}
   }{
     \begin{array}{l}
       \LCFElabSt{\Upsilon}{\Gamma}{t_1}{J}{P}{\vec{u}\oplus\alpha}{\mu_1}\\
       \LCFElabSt{\Upsilon,\vec{u}:\SortHyp}{\Gamma}{t_2}{J_i}{Q}{\StreamChop{\vec{u}\oplus\alpha}{\mu_1}}{\mu_2}
     \end{array} &
   }
 \]

Finally, the action of the multi-tactics is defined:
\[
  \infer{
    \LCFElabSt{\Upsilon}{\Gamma}{\Box t}{P}{
      \LCFMergeProofState{\Dom{P}}{J}{Q_J}
    }{\alpha}{\mu}
  }{
    \HypJ{
      \LCFElabSt{\Upsilon,\vec{u}:\SortHyp}{\Gamma}{t}{J}{Q_J}{\alpha}{\mu_J}
    }{
      \Member{J}{\Dom{P}}
    } &
    \Match{\bigsqcup_{J\in\Dom{P}}\mu_J}{\mu}
  }
\]

\[
  \infer{
    \LCFElabSt{\Upsilon}{\Gamma}{
      \TacEach{t_0,\dots,t_n}
    }{P}{
      \LCFMergeProofState{\Dom{P}}{J}{Q_J}
    }{\alpha}{\mu}
  }{
    \HypJ{
      \LCFElabSt{\Upsilon,\vec{u}:\SortHyp}{\Gamma}{t_i}{J_i}{Q_{J_i}}{\alpha}{\mu_{J_i}}
    }{
      \Member{J_i}{\Dom{P}}
    } &
    \Match{\bigsqcup_{J\in\Dom{P}}\mu_J}{\mu}
  }
\]

\[
  \infer{
    \LCFElabSt{\Upsilon}{\Gamma}{
      \Diamond_i t
    }{P}{
      \LCFMergeProofState{\Dom{P}}{J_j}{
        \left\{
          \begin{array}{lcl}
            j=i &\mapsto &Q\\
            j\not=i &\mapsto &\MLPair{[J_j]}{\lambda [x].x}
          \end{array}
        \right\}
      }
    }{\alpha}{\mu}
  }{
    \LCFElabSt{\Upsilon,\vec{u}:\SortHyp}{\Gamma}{t}{\Dom{P}_i}{Q}{\alpha}{\mu}
  }
\]


