\chapter{Nominal LCF: a language for tactics}

In a sequent calculus, left rules add hypotheses to the context; for instance,
consider the left rule for positive conjunctions:
\[
  \infer[{\otimes_L^{\IMode{x},\OMode{y},\OMode{z}}}]{
    \IMode{H,x:A\otimes B}\gg\IMode{C}
  }{
    \IMode{H,x:A\otimes B,y:A,z:B}\gg\IMode{
      \IMode{\Subst{\Pair{y}{z}}{x}{C}}
    }
  }
\]
%

From a proof refinement perspective (see~\cite{constable:1986}), such a rule is
typically manifested as an ML tactic $\mathtt{\otimes_L}[x,y,z]$ which takes
three names as parameters: the target hypothesis $\IMode{x}$, and the names to
use for the new hypotheses $\OMode{y},\OMode{z}$. However, whilst the identity
of the name $x$ is essential to the meaning of the tactic, the names supplied
for the generated hypotheses can be freshly renamed with impunity.

Indeed, in a proof term assignment for this sequent calculus, the corresponding
elimination form would \emph{bind} variables $x,y$ rather than take them as
parameters. However, in the standard LCF tactic paradigm, it is not possible to
reproduce this structure, because the sequencing of rules is mediated by the
general purpose $\mathtt{THEN}$ tactical, which has no knowledge of names or
binding.

We will design a language for tactics called \textbf{Nominal LCF} which
supports a distinction between names bound and names taken as parameters, and
then show how it can be elaborated into standard LCF.

\section{The LCF Tactic Language}
\newcommand\MLTypeDecl[1]{\mathtt{type}\ #1}
\newcommand\PartialFun[2]{#1\rightharpoonup #2}
\newcommand\LCFJudgment{\mathit{judgment}}
\newcommand\LCFEvidence{\mathit{evidence}}
\newcommand\LCFState{\mathit{state}}
\newcommand\LCFStateApply[2]{#1\star #2}
\newcommand\LCFTactic{\mathit{tactic}}
\newcommand\MLList[1]{#1\;\mathit{list}}
\newcommand\MLAtom{\mathbb{A}}
\newcommand\MLNat{\mathbb{N}}
\newcommand\MLStream[1]{{#1}^{\MLNat}}
\newcommand\MLPair[2]{\left(#1, #2\right)}
\newcommand\LCFAtomicTactic{\mathit{atactic}}
\newcommand\StreamTake[2]{\bar{#1}[#2]}
\newcommand\StreamChop[2]{[#2]\bar{#1}}
\newcommand\MLListSplit[2]{\mathsf{split}(#1, #2)}
\newcommand\LCFStateSplit[4]{\mathsf{split}_{#1}^{#2}(#4, #3)}
\DeclarePairedDelimiter{\MLLength}{\lVert}{\rVert}


The essence of the LCF tactic system is captured in the following (idealized)
ML signature:

\[
  \begin{array}{lcl}
    \MLTypeDecl{\LCFJudgment}\\
    \MLTypeDecl{\LCFEvidence}\\
    \MLTypeDecl{\LCFState} &= &\MLList{\LCFJudgment} \otimes (\PartialFun{\MLList{\LCFEvidence}}{\LCFEvidence})\\
    \MLTypeDecl{\LCFTactic} &= &\PartialFun{\LCFJudgment}{\LCFState}
  \end{array}
\]

In other words, a tactic is a partial function that takes a goal to its
subgoals, and specifies how to transform the evidence of its subgoals into the
evidence for the main goal. In the case of the sequence calculus we were
considering, \verb!judgment! would be a type of sequents. We will write
$\Dom{P}$ for the list of subgoals $\pi_1(P)$ to a proof state
$\Member{P}{\LCFState}$, $\MLLength{P}$ for the length of $\Dom{P}$, and
$\LCFStateApply{P}{\vec{x}}$ for the application of the hypothetical evidence
$\pi_2(P)$ to the concrete evidence $\Member{\vec{x}}{\MLList{\LCFEvidence}}$.

Now, in general a tactic may need to consume names from a \emph{name store},
which is an infinite stream of \emph{atoms} or \emph{symbols}:

\[
  \begin{array}{lcl}
    \MLTypeDecl{\MLAtom}\\
    \MLTypeDecl{\LCFAtomicTactic} &= &\MLStream{\MLAtom} \to \LCFTactic
  \end{array}
\]

\newcommand\KleeneEq[2]{\IMode{#1}\approx \IMode{#2}}
\newcommand\ModC[1]{\mathsf{M}(#1)}

\subsection{Atomic tactics and their continuity}

Left sequent rules can be coded as so-called \emph{atomic tactics}, tactics
which consume a stream of names. In fact, every such tactic is
\emph{continuous} in a specific sense. For an atomic sequence
$\Member{\alpha}{\MLStream{\MLAtom}}$ and a natural number
$\Member{n}{\MLNat}$, let $\StreamTake{\alpha}{n}$ be the initial segment of
$\alpha$ of length $n$; let $\StreamChop{\alpha}{n}$ be infinite suffix of
$\alpha$ got by chopping off the initial prefix $\StreamTake{\alpha}{n}$. Let
$\KleeneEq{M}{N}$ be \emph{observational equivalence}: $M$ and $N$ evaluate to
equal values, or they both diverge.

Then, for any atomic tactic $T$ and judgment $J$, we can calculate a
modulus of continuity:
\begin{equation}
  \forall \Member{\alpha}{\MLStream{\MLAtom}}.
  \exists \OMode{n}\in\IMode{\MLNat}.
  \forall \Member{\beta}{\MLStream{\MLAtom}}.
    \IsEq{\bar{\alpha}(n)}{\bar{\beta}(n)}\implies \KleeneEq{T(\alpha,J)}{T(\beta,J)}
  \tag{continuity}
\end{equation}

This calculation can be realized computationally in our metalanguage in a
number of ways, but for our purposes it suffices to remark that it is a fact
concerning all computable stream processors. Let
$\Member{\ModC{T}}{\LCFJudgment\to\MLStream{\MLAtom}\to\MLNat}$ calculate the modulus of continuity
for an atomic tactic $\Member{T}{\LCFAtomicTactic}$ with name store $\alpha$.

\section{Nominal LCF}

\subsection{Static Semantics}

\newcommand\SortATac{\mathtt{atac}}
\newcommand\SortBTac{\mathtt{btac}}
\newcommand\SortTac{\mathtt{tac}}
\newcommand\SortMTac{\mathtt{mtac}}
\newcommand\SortHyp{\mathtt{hyp}}

We will define the \textbf{Nominal LCF} language by specifying an abt signature
for it; at its heart is decomposition of the various sequencing tacticals
$\mathtt{THEN}$, $\mathtt{THENL}$, etc.\ of LCF into a single sequencing
tactical combined a separate notion of \emph{multi-tactic}.

First, we define sorts for tactics, atomic tactics, binding tactics and multi-tactics
respectively:
\begin{gather*}
  \infer{
    \IsSort{\SortTac}
  }{}
  \qquad
  \infer{
    \IsSort{\SortATac}
  }{}
  \qquad
  \infer{
    \IsSort{\SortBTac}
  }{}
  \qquad
  \infer{
    \IsSort{\SortMTac}
  }{}
\end{gather*}

We also provide a sort to classify hypotheses:
\[
  \infer{
    \IsSort{\SortHyp}
  }{
  }
\]

Now, we'll define the operators of \textbf{Nominal LCF}; note that the
operators of sort $\SortATac$ are arbitrary and are provided only for the sake
of illustration. We will consider the definition of \textbf{Nominal LCF} as
over some signature $\Sigma$ of atomic tactics.

\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{id}}{
      \MkArity{}{\SortATac}
    }
  }{
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon}{\mathtt{fail}}{
      \MkArity{}{\SortATac}
    }
  }{
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon,a:\SortHyp}{\mathtt{elim}[a]}{
      \MkArity{}{\SortATac}
    }
  }{
  }
\]
\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{fix}}{
      \MkArity{
        \MkValence{}{\SortATac}{\SortATac}
      }{\SortATac}
    }
  }{
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon}{\mathtt{let}}{
      \MkArity{
        \MkValence{}{}{\SortTac},
        \MkValence{}{\SortATac}{\SortATac}
      }{\SortATac}
    }
  }{
  }
\]

\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{seq}_n}{
      \MkArity{
        \MkValence{}{}{\SortBTac},
        \MkValence{\SortHyp^n}{}{\SortMTac}
      }{\SortTac}
    }
  }{
    \Member{n}{\MLNat}
  }
\]

\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{smash}}{
      \MkArity{
        \MkValence{}{}{\SortATac},
        \MkValence{}{}{\SortATac}
      }{\SortBTac}
    }
  }{
    \Member{n}{\MLNat}
  }
\]

\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{all}}{
      \MkArity{
        \MkValence{}{}{\SortTac}
      }{\SortMTac}
    }
  }{
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon}{\mathtt{each}_n}{
      \MkArity{
        \MkValence{}{}{\SortTac}^n
      }{\SortMTac}
    }
  }{
    \Member{n}{\MLNat}
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon}{\mathtt{some}_i}{
      \MkArity{
        \MkValence{}{}{\SortTac}
      }{\SortMTac}
    }
  }{
    \Member{i}{\MLNat}
  }
\]

\newcommand\TacSmash[2]{#1\supsetplus #2}
\newcommand\TacEach[1]{\llparenthesis #1\rrparenthesis}
\newcommand\TacSeq[3]{#2\leftarrow #1; #3}
\newcommand\TacFix[2]{\mu #1. #2}
\newcommand\TacLet[3]{\mathit{let}\ #2 := #1\ \mathit{in}\ #3}

For the sake of clarity, we introduce the following notational abbreviations
for tactic expressions:
\begin{align*}
  \ADefine{
    t_1;t_2
  }{
    \App{\mathtt{seq}_0}{\MkAbs{}{}{t_1};\MkAbs{}{}{t_2}}
  }\\
  \ADefine{
    \TacSeq{t_1}{a_0,\dots,a_n}{t_2}
  }{
  \App{\mathtt{seq}_n}{\MkAbs{}{}{t_1};\MkAbs{a_0,\dots,a_n}{}{t_2}}
  }\\
  \ADefine{
    \TacSmash{t_1}{t_2}
  }{
    \App{\mathtt{smash}}{\MkAbs{}{}{t_1};\MkAbs{}{}{t_n}}
  }\\
  \ADefine{
    \Box t
  }{
    \App{\mathtt{all}}{\MkAbs{}{}{t}}
  }\\
  \ADefine{
    \TacEach{t_1,\dots,t_n}
  }{
    \App{\mathtt{each}_n}{\MkAbs{}{}{t_1};\dots;\MkAbs{}{}{t_n}}
  }\\
  \ADefine{
    \Diamond_i t
  }{
    \App{\mathtt{some}_i}{\MkAbs{}{}{t}}
  }\\
  \ADefine{
    \TacFix{x}{\MV{t}[x]}
  }{
    \App{\mathtt{fix}}{\MkAbs{}{x}{\MV{t}[x]}}
  }\\
  \ADefine{
    \TacLet{t_1}{x}{\mathfrak{t}_2[x]}
  }{
    \App{\mathtt{let}}{
      \MkAbs{}{}{t_1};
      \MkAbs{}{x}{\mathfrak{t}_2[x]}
    }
  }
\end{align*}

\subsection{Dynamic Semantics}

\newcommand\LCFElab[6]{%
  \mathcal{M}%
  \SemBrackets{
  \IMode{#1}\parallel\IMode{#2}\vdash%
    \IMode{#3}%
    :\IMode{#4}
  }_\IMode{#5}%
  \equiv\OMode{#6}%
}

We will now give a denotational semantics for \textbf{Nominal LCF} by
interpreting its syntax into a model $\mathcal{M}$, taking each tactic
expression to an atomic LCF tactic. The intepretation
$\LCFElab{\Upsilon}{\Gamma}{t}{\tau}{\rho}{T}$ is defined by recursion on $t$ of sorts
$\SortATac,\SortBTac,\SortTac$ such that $\Member{T}{\LCFAtomicTactic}$,
presupposing that $\Member{\rho(x)}{\LCFAtomicTactic}$ for each
$\Member{x:\SortATac}{\Gamma}$.
To start with, variable tactics are simply projected from the
environment $\rho$:
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{x}{\SortATac}{\rho}{}{\rho(x)}
  }{
  }
\]

The atomic tacticals are interpreted as follows (we omit the interpretation of
$\mathtt{elim}[a]$, which will depend on the logic):
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{\mathtt{id}}{\SortATac}{\rho}{
      \lambda\alpha.\mathtt{ID}
    }
  }{
  }
  \qquad
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{\mathtt{fail}}{\SortATac}{\rho}{
      \lambda\alpha.\mathtt{FAIL}
    }
  }{
  }
\]
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{\TacLet{t_1}{x}{\MV{t}_2[x]}}{\SortATac}{\rho}{
      T_2
    }
  }{
    \LCFElab{\Upsilon}{\Gamma}{t_1}{\SortTac}{\rho}{T_1} &
    \LCFElab{\Upsilon}{\Gamma,x:\SortATac}{\MV{t}_2[x]}{\SortATac}{
      \rho,x\mapsto T_1
    }{
      T_2
    }
  }
\]

The rule for the \emph{smash} tactical $\TacSmash{t_1}{t_2}$ exploits the
continuity of atomic tactics to divide up the name store between $t_1$ and $t_2$:
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{\TacSmash{t_1}{t_2}}{\SortBTac}{\rho}{
      \lambda\alpha.\mathtt{THEN}(T_1(\alpha),\lambda J. T_2(\StreamChop{\alpha}{\ModC{T_1}(J,\alpha)}))
    }
  }{
    \LCFElab{\Upsilon}{\Gamma}{t_1}{\SortATac}{\rho}{T_1} &
    \LCFElab{\Upsilon}{\Gamma}{t_2}{\SortATac}{\rho}{T_2}
  }
\]

Next, we define the behavior of the sequencing tactical, by case on the multi-tactical:
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{
      \TacSeq{t_1}{\vec{u}}{\Box t_2}
    }{\SortTac}{\rho}{
      \lambda\alpha.\mathtt{THEN}(T_1(\vec{u}\oplus\alpha), T_2(\StreamChop{\vec{u}\oplus\alpha}{\ModC{T_1}(J,\vec{u}\oplus\alpha)})
    }
  }{
    \LCFElab{\Upsilon}{\Gamma}{t_1}{\SortBTac}{\rho}{T_1} &
    \LCFElab{\Upsilon,\vec{u}:\SortHyp}{\Gamma}{t_2}{\SortTac}{\rho}{T_2}
  }
\]
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{
      \TacSeq{t}{\vec{u}}{\TacEach{t_0,\dots,t_n}}
    }{\SortTac}{\rho}{
      \lambda\alpha.\mathtt{THENL}(T(\vec{u}\oplus\alpha),
        \left[
          T_i(\StreamChop{\vec{u}\oplus\alpha}{\ModC{T}(J,\vec{u}\oplus\alpha)})\mid i<n
        \right])
    }
  }{
    \LCFElab{\Upsilon}{\Gamma}{t}{\SortBTac}{\rho}{T}&
    \HypJ{
      \LCFElab{\Upsilon,\vec{u}:\SortHyp}{\Gamma}{t_i}{\SortTac}{\rho}{T_i}
    }{
      \LT{i}{n}
    }
  }
\]
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{
      \TacSeq{t_1}{\vec{u}}{\Diamond_i t_2}
    }{\SortTac}{\rho}{
      \lambda\alpha.\mathtt{THENF}(T_1(\vec{u}\oplus\alpha), i, T_2(\StreamChop{\vec{u}\oplus\alpha}{\ModC{T_1}(J,\vec{u}\oplus\alpha)})
    }
  }{
    \LCFElab{\Upsilon}{\Gamma}{t_1}{\SortTac}{\rho}{T_1} &
    \LCFElab{\Upsilon,\vec{u}:\SortHyp}{\Gamma}{t_2}{\SortTac}{\rho}{T_2}
  }
\]
