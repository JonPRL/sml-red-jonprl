\chapter{Nominal LCF: a language for tactics}

In a sequent calculus, left rules add hypotheses to the context; for instance,
consider the left rule for positive conjunctions:
\[
  \infer[{\otimes_L^{\IMode{x},\OMode{y},\OMode{z}}}]{
    \IMode{H,x:A\otimes B}\gg\IMode{C}
  }{
    \IMode{H,x:A\otimes B,y:A,z:B}\gg\IMode{
      \IMode{\Subst{\Pair{y}{z}}{x}{C}}
    }
  }
\]
%

From a proof refinement perspective (see~\cite{constable:1986}), such a rule is
typically manifested as an ML tactic $\mathtt{\otimes_L}[x,y,z]$ which takes
three names as parameters: the target hypothesis $\IMode{x}$, and the names to
use for the new hypotheses $\OMode{y},\OMode{z}$. However, whilst the identity
of the name $x$ is essential to the meaning of the tactic, the names supplied
for the generated hypotheses can be freshly renamed with impunity.

Indeed, in a proof term assignment for this sequent calculus, the corresponding
elimination form would \emph{bind} variables $x,y$ rather than take them as
parameters. However, in the standard LCF tactic paradigm, it is not possible to
reproduce this structure, because the sequencing of rules is mediated by the
general purpose $\mathtt{THEN}$ tactical, which has no knowledge of names or
binding.

We will design a language for tactics called \textbf{Nominal LCF} which
supports a distinction between names bound and names taken as parameters, and
then show how it can be elaborated into standard LCF.

\section{The LCF Metalanguage}
\newcommand\MLTypeDecl[1]{\mathtt{type}\ #1}
\newcommand\PartialFun[2]{#1\rightharpoonup #2}
\newcommand\LCFJudgment{\mathit{judgment}}
\newcommand\LCFEvidence{\mathit{evidence}}
\newcommand\LCFState{\mathit{state}}
\newcommand\LCFStateApply[2]{#1\star #2}
\newcommand\LCFTactic{\mathit{tactic}}
\newcommand\MLList[1]{#1\;\mathit{list}}
\newcommand\MLAtom{\mathbb{A}}
\newcommand\MLNat{\mathbb{N}}
\newcommand\MLStream[1]{{#1}^{\MLNat}}
\newcommand\MLPair[2]{\left(#1, #2\right)}
\newcommand\LCFNominalTactic{\MLStream{\MLAtom}\to\LCFTactic}
\newcommand\StreamTake[2]{\bar{#1}[#2]}
\newcommand\StreamChop[2]{[#2]\bar{#1}}
\newcommand\MLListSplit[2]{\mathsf{split}(#1, #2)}
\newcommand\LCFStateSplit[4]{\mathsf{split}_{#1}^{#2}(#4, #3)}
\DeclarePairedDelimiter{\MLLength}{\lVert}{\rVert}


The essence of the LCF tactic system is captured by fixing a type
$\LCFJudgment$ of judgments and $\LCFEvidence$ of evidence, and then using them
to define the notion of a proof state and a tactic:
\begin{align*}
  \ADefine{
    \LCFState
  }{
    \MLList{\LCFJudgment} \otimes (\PartialFun{\MLList{\LCFEvidence}}{\LCFEvidence})
  }\\
  \ADefine{
    \LCFTactic
  }{
    \PartialFun{\LCFJudgment}{\LCFState}
  }
\end{align*}

In other words, a tactic is a partial function that takes a goal to its
subgoals, and specifies how to transform the evidence of its subgoals into the
evidence for the main goal. In the case of the sequence calculus we were
considering, $\LCFJudgment$ would be a type of sequents.

\paragraph{Standard LCF Tacticals}
There are a number of useful tacticals (higher order tactics) that can be
defined for the LCF metalanguage. In particular, we have the following
sequencing tacticals:
\begin{align*}
  \IMode{\mathtt{THEN}} &\in \IMode{\LCFTactic \otimes \LCFTactic \to \LCFTactic}\\
  \IMode{\mathtt{THENL}} &\in \IMode{\LCFTactic \otimes \MLList{\LCFTactic} \to \LCFTactic}\\
  \IMode{\mathtt{THENF}} &\in \IMode{\LCFTactic \otimes \MLNat \otimes \LCFTactic \to \LCFTactic}\\
\end{align*}

The $\mathtt{THEN}(T_1,T_2)$ tactical applies $T_1$ to the goal, and then
applies $T_2$ to all the subgoals generated by $T_1$;
$\mathtt{THENL}(T,\vec{T})$ is similar, except that it applies the list
$\vec{T}$ of tactics pointwise to the subgoals generated by the application of
$T$; finally, $\mathtt{THENF}(T_1, i, T_2)$ applies $T_2$ to the $i$th subgoal
generated by $T_1$. If co-lists are used instead of lists, then all three
tactics can be defined in terms of $\mathtt{THENL}$.

\paragraph{Nominal tactics and their continuity}


\newcommand\KleeneEq[2]{\IMode{#1}\approx \IMode{#2}}
\newcommand\ModC[1]{\mathsf{M}(#1)}

Now, frequently a tactic may need to consume names from a name store, which can
be represented as infinite stream (choice sequence) of \emph{atoms} or
\emph{symbols}; let $\MLAtom$ be the type of atoms; then, a \emph{nominal
tactic} is a function from choice sequences of atoms to tactics, $\LCFNominalTactic$.

Left sequent rules can be coded as nominal tactics, pulling the names for their bound
variables from the supplied choice sequence of atoms; moreover, every such tactic
is \emph{continuous} in a specific sense. For a choice sequence
$\Member{\alpha}{\MLStream{\MLAtom}}$ and a natural number
$\Member{n}{\MLNat}$, let $\StreamTake{\alpha}{n}$ be the initial segment of
$\alpha$ of length $n$; let $\StreamChop{\alpha}{n}$ be infinite suffix of
$\alpha$ got by chopping off the initial prefix $\StreamTake{\alpha}{n}$. Let
$\KleeneEq{M}{N}$ be \emph{observational equivalence}: $M$ and $N$ evaluate to
equal values, or they both diverge.

Then, for any nominal tactic $T$ and judgment $J$, we can calculate a
modulus of continuity:
\begin{equation}
  \forall \Member{\alpha}{\MLStream{\MLAtom}}.
  \exists \OMode{n}\in\IMode{\MLNat}.
  \forall \Member{\beta}{\MLStream{\MLAtom}}.
    \IsEq{\bar{\alpha}(n)}{\bar{\beta}(n)}\implies \KleeneEq{T(\alpha,J)}{T(\beta,J)}
  \tag{continuity}
\end{equation}

This calculation can be realized computationally in our metalanguage in a
number of ways, but for our purposes it suffices to remark that it is a fact
concerning all computable stream processors. Let
$\Member{\ModC{T}}{\LCFJudgment\to\MLStream{\MLAtom}\to\MLNat}$ calculate the
modulus of continuity for a nominal tactic $\Member{T}{\LCFNominalTactic}$ with
name store $\alpha$.

\section{Nominal LCF}

\newcommand\SortTac{\mathtt{tac}}
\newcommand\SortMTac{\mathtt{mtac}}
\newcommand\SortHyp{\mathtt{hyp}}

We will define the \textbf{Nominal LCF} language by specifying an abt signature
for it; at its heart is decomposition of the various sequencing tacticals
$\mathtt{THEN}$, $\mathtt{THENL}$, etc.\ of LCF into a single sequencing
tactical combined a separate notion of \emph{multi-tactic}.
First, we define sorts for nominal tactics and multi-tactics respectively, as
well as a sort for hypothesis names:
\[
  \infer{
    \IsSort{\SortTac}
  }{}
  \qquad
  \infer{
    \IsSort{\SortMTac}
  }{}
  \qquad
  \infer{
    \IsSort{\SortHyp}
  }{
  }
\]

Now, we'll define the operators of \textbf{Nominal LCF}; note that the atomic
tactics like $\mathtt{id}$, $\mathtt{fail}$ and $\mathtt{elim}[a]$ are
arbitrary and included only for the sake of illustration.

\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{id}}{
      \MkArity{}{\SortTac}
    }
  }{
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon}{\mathtt{fail}}{
      \MkArity{}{\SortTac}
    }
  }{
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon,a:\SortHyp}{\mathtt{elim}[a]}{
      \MkArity{}{\SortTac}
    }
  }{
  }
\]

\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{fix}}{
      \MkArity{
        \MkValence{}{\SortTac}{\SortTac}
      }{\SortTac}
    }
  }{
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon}{\mathtt{let}}{
      \MkArity{
        \MkValence{}{}{\SortTac},
        \MkValence{}{\SortTac}{\SortTac}
      }{\SortTac}
    }
  }{
  }
\]

\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{seq}_n}{
      \MkArity{
        \MkValence{}{}{\SortTac},
        \MkValence{\SortHyp^n}{}{\SortMTac}
      }{\SortTac}
    }
  }{
    \Member{n}{\MLNat}
  }
\]

\[
  \infer{
    \IsOperator{\Upsilon}{\mathtt{all}}{
      \MkArity{
        \MkValence{}{}{\SortTac}
      }{\SortMTac}
    }
  }{
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon}{\mathtt{each}_n}{
      \MkArity{
        \MkValence{}{}{\SortTac}^n
      }{\SortMTac}
    }
  }{
    \Member{n}{\MLNat}
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon}{\mathtt{some}_i}{
      \MkArity{
        \MkValence{}{}{\SortTac}
      }{\SortMTac}
    }
  }{
    \Member{i}{\MLNat}
  }
\]

\newcommand\TacEach[1]{\llparenthesis #1\rrparenthesis}
\newcommand\TacSeq[3]{#2\leftarrow #1; #3}
\newcommand\TacFix[2]{\mu #1. #2}
\newcommand\TacLet[3]{\mathit{let}\ #2 := #1\ \mathit{in}\ #3}

For the sake of clarity, we introduce the following notational abbreviations
for tactic expressions:
\begin{align*}
  \ADefine{
    t_1;t_2
  }{
    \App{\mathtt{seq}_0}{\MkAbs{}{}{t_1};\MkAbs{}{}{t_2}}
  }\\
  \ADefine{
    \TacSeq{t_1}{a_0,\dots,a_n}{t_2}
  }{
  \App{\mathtt{seq}_n}{\MkAbs{}{}{t_1};\MkAbs{a_0,\dots,a_n}{}{t_2}}
  }\\
  \ADefine{
    \Box t
  }{
    \App{\mathtt{all}}{\MkAbs{}{}{t}}
  }\\
  \ADefine{
    \TacEach{t_1,\dots,t_n}
  }{
    \App{\mathtt{each}_n}{\MkAbs{}{}{t_1};\dots;\MkAbs{}{}{t_n}}
  }\\
  \ADefine{
    \Diamond_i t
  }{
    \App{\mathtt{some}_i}{\MkAbs{}{}{t}}
  }\\
  \ADefine{
    \TacFix{x}{\MV{t}[x]}
  }{
    \App{\mathtt{fix}}{\MkAbs{}{x}{\MV{t}[x]}}
  }\\
  \ADefine{
    \TacLet{t_1}{x}{\mathfrak{t}_2[x]}
  }{
    \App{\mathtt{let}}{
      \MkAbs{}{}{t_1};
      \MkAbs{}{x}{\mathfrak{t}_2[x]}
    }
  }
\end{align*}

\subsection{Denotational Semantics}

\newcommand\LCFElaboration[5]{%
  \mathcal{M}%
  \SemBrackets{
    #1\parallel #2\vdash%
    #3%
    % :#4
  }_{#5}%
}

\newcommand\LCFElab[6]{%
  \LCFElaboration{\IMode{#1}}{\IMode{#2}}{\IMode{#3}}{\IMode{#4}}{\IMode{#5}}%
  \equiv\OMode{#6}%
}

We will now give a denotational semantics for \textbf{Nominal LCF} by
interpreting every tactic expression into an LCF nominal tactic. The
intepretation $\LCFElab{\Upsilon}{\Gamma}{t}{\tau}{\rho}{T}$ is defined by
recursion on $t:\SortTac$ such that $\Member{T}{\LCFNominalTactic}$,
presupposing that $\Member{\rho(x)}{\LCFNominalTactic}$ for each
$\Member{x:\SortTac}{\Gamma}$.  To start with, variable tactics are simply
projected from the environment $\rho$:
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{x}{\SortTac}{\rho}{\rho(x)}
  }{
  }
\]

The basic tactics and tacticals are interpreted as follows (we omit the interpretation of
$\mathtt{elim}[a]$, which will depend on the logic):
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{\mathtt{id}}{\SortTac}{\rho}{
      \lambda\alpha.\mathtt{ID}
    }
  }{
  }
  \qquad
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{\mathtt{fail}}{\SortTac}{\rho}{
      \lambda\alpha.\mathtt{FAIL}
    }
  }{
  }
\]
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{\TacLet{t_1}{x}{\MV{t}_2[x]}}{\SortTac}{\rho}{
      T_2
    }
  }{
    \LCFElab{\Upsilon}{\Gamma}{t_1}{\SortTac}{\rho}{T_1} &
    \LCFElab{\Upsilon}{\Gamma,x:\SortTac}{\MV{t}_2[x]}{\SortTac}{
      \rho,x\mapsto T_1
    }{
      T_2
    }
  }
\]
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{\TacFix{x}{\MV{t}[x]}}{\SortTac}{\rho}{
      \mathtt{fix}%
      \left(\lambda T.
        \LCFElaboration{\Upsilon}{\Gamma,x:\SortTac}{\MV{t}[x]}{\SortTac}{\rho,x\mapsto T}
      \right)
    }
  }{
  }
\]

Next, we define the behavior of the sequencing tactical, by case on the multi-tactical:
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{
      \TacSeq{t_1}{\vec{u}}{\Box t_2}
    }{\SortTac}{\rho}{
      \lambda\alpha, J.\mathtt{THEN}(T_1(\vec{u}\oplus\alpha), \lambda J'. T_2(\StreamChop{\vec{u}\oplus\alpha}{\ModC{T_1}(J,\vec{u}\oplus\alpha)}, J'))(J)
    }
  }{
    \LCFElab{\Upsilon}{\Gamma}{t_1}{\SortTac}{\rho}{T_1} &
    \LCFElab{\Upsilon,\vec{u}:\SortHyp}{\Gamma}{t_2}{\SortTac}{\rho}{T_2}
  }
\]
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{
      \TacSeq{t}{\vec{u}}{\TacEach{t_0,\dots,t_n}}
    }{\SortTac}{\rho}{
      \lambda\alpha, J.\mathtt{THENL}(T(\vec{u}\oplus\alpha),
        \left[
          \lambda J'. T_i(\StreamChop{\vec{u}\oplus\alpha}{\ModC{T}(J,\vec{u}\oplus\alpha)}, J')\mid i<n
        \right])(J)
    }
  }{
    \LCFElab{\Upsilon}{\Gamma}{t}{\SortTac}{\rho}{T}&
    \HypJ{
      \LCFElab{\Upsilon,\vec{u}:\SortHyp}{\Gamma}{t_i}{\SortTac}{\rho}{T_i}
    }{
      \LT{i}{n}
    }
  }
\]
\[
  \infer{
    \LCFElab{\Upsilon}{\Gamma}{
      \TacSeq{t_1}{\vec{u}}{\Diamond_i t_2}
    }{\SortTac}{\rho}{
      \lambda\alpha, J.
      \mathtt{THENF}(T_1(\vec{u}\oplus\alpha), i, \lambda J'. T_2(\StreamChop{\vec{u}\oplus\alpha}{\ModC{T_1}(J,\vec{u}\oplus\alpha)}, J'))(J)
    }
  }{
    \LCFElab{\Upsilon}{\Gamma}{t_1}{\SortTac}{\rho}{T_1} &
    \LCFElab{\Upsilon,\vec{u}:\SortHyp}{\Gamma}{t_2}{\SortTac}{\rho}{T_2}
  }
\]
