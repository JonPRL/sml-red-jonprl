\documentclass{report}
\usepackage{epigraph}
\usepackage{fullpage}
\usepackage{proof}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{notation/judgments}
\usepackage{notation/abts}
\usepackage{ifthen}
\usepackage{jonprl-doc}

\title{The Definition of \RedJonPRL{},\\\emph{the people's refinement logic}}
\author{The JonPRL Group}
\date{\today}

\begin{document}

\maketitle
\tableofcontents

\chapter{Signatures}

\epigraph{\OMode{\emph{\textsf{Decisively Smash The Formalist Clique!}}}}{\textsf{Chairman Jon}}

A \emph{signature} is a collection of definitions, including terms, tactics and theorems.

\section{Grammar}
\label{sec:sig-grammar}

The grammar of \RedJonPRL{} signatures is presented in
Figure~\ref{fig:sig-grammar}. Note that an optional production of sort $s$ is
formatted $\Optional{s}$ in the rules.

\begin{figure}[H]
  \begin{displaymath}
    \begin{array}{rcll}
       \SortSigExpr & ::=
         & \EmptySig & \text{empty signature}\\
         && \ExtendSig{\SortSigExpr}{\SortSigDecl} & \text{signature extension}\\
       \SortSigDecl & ::=
         & \DefDecl{\SortOpId}{\SortParams}{\SortArgs}{\SortSortId}{\SortTerm} & \text{operator definition}\\
         && \TacDecl{\SortOpId}{\SortParams}{\SortArgs}{\SortTerm} & \text{tactic definition}\\
         && \ThmDecl{\SortOpId}{\SortParams}{\SortArgs}{\SortTerm}{\SortTerm} & \text{theorem declaration}\\
       \SortParams & ::=
         & \EmptyCtx & \text{empty parameter list}\\
         && \ExtendCtx{\SortParams}{\SortSymBind} & \text{parameter list extension}\\
       \SortArgs & ::=
         & \EmptyCtx & \text{empty argument list}\\
         && \ExtendCtx{\SortArgs}{\SortMetaBind}  & \text{argument list extension}\\
       \SortSymBind & ::=
         & \Bind{\SortSymId}{\SortSortId} & \text{symbol binding}\\
       \SortMetaBind & ::=
         & \Bind{\SortMetaId}{\SortValence} & \text{metavariable binding}\\
       \SortValence & ::=
         & \Valence{\SortSortList}{\SortSortList}{\SortSortId} & \text{valence}\\
       \SortSortList & ::=
         & \EmptyCtx & \text{empty sort list}\\
         && \ExtendCtx{\SortSortList}{\SortSortId} & \text{sort list extension}
     \end{array}
  \end{displaymath}

  \caption{%
    Grammar of signature expressions. The identifier sorts $\SortOpId$,
    $\SortSortId$, $\SortSymId$ and $\SortMetaId$ can be assumed to be arbitrary
    strings; the sort $\SortTerm$ is left uninterpreted.%
  }
  \label{fig:sig-grammar}
\end{figure}

\section{Static Semantics}
\label{sec:sig-statics}

\newcommand\SemSym{\mathrm{Sym}}
\newcommand\SemMetavar{\mathrm{Metavar}}
\newcommand\SemOpid{\mathrm{Opid}}
\newcommand\SemSig{\mathrm{Sig}}
\newcommand\SemParams{\mathrm{Params}}
\newcommand\SemArgs{\mathrm{Args}}
\newcommand\SemTerm[3]{\mathrm{Tm}(#1,#2,#3)}
\newcommand\SemSort{\mathrm{Sort}}
\newcommand\SemValence{\mathrm{Valence}}
\newcommand\SemDecl{\mathrm{Decl}}
\newcommand\Partial[2]{#1\rightharpoonup #2}

\newcommand\SemExprs{\mathbf{E}}
\newcommand\AbtSortTac{\mathtt{tac}}
\newcommand\AbtSortThm{\mathtt{thm}}
\newcommand\AbtSortExp{\mathtt{exp}}
\newcommand\AbtSortOpid{\mathtt{opid}}
\newcommand\OpProve{\mathtt{prove}}

\newcommand\OpCust

The static semantics for \RedJonPRL{} signatures begins with a specification of
the class of \emph{semantic} objects that will serve as the meanings for the
\emph{syntactic} objects defined in Section~\ref{sec:sig-grammar}. We assume an
ambient abstract binding tree signature such that at least the following facts
hold:

\[
  \infer{
    \IsSort{\AbtSortTac}
  }{
  }
  \qquad
  \infer{
    \IsSort{\AbtSortThm}
  }{
  }
  \qquad
  \infer{
    \IsSort{\AbtSortExp}
  }{
  }
  \qquad
  \infer{
    \IsSort{\AbtSortOpid}
  }{
  }
\]
\[
  \infer{
    \IsOperator{\Upsilon}{\OpProve}{
      \MkArity{
        \MkValence{}{}{\AbtSortExp},
        \MkValence{}{}{\AbtSortTac}
      }{\AbtSortThm}
    }
  }{
  }
\]

Then, our semantic objects are defined as in Figure~\ref{fig:sig-semantic-objects}.

\begin{figure}[H]
  \begin{displaymath}
    \begin{array}{rclcl}
      a,b &\in &\SemSym\\
      \MV{m},\MV{n} &\in &\SemMetavar\\
      \sigma,\tau &\in &\SemSort &\triangleq & \MkSet{\tau\mid\IsSort{\tau}}\\
      v &\in &\SemValence &\triangleq & \MkSet{v\mid\IsValence{v}}\\
      \vartheta &\in &\SemOpid  &\triangleq &\SemSym\\
      \Upsilon &\in &\SemParams &\triangleq & \Partial{\SemSym}{\SemSort}\\
      \Theta &\in &\SemArgs &\triangleq & \Partial{\SemMetavar}{\SemValence}\\
      M,N &\in &\SemTerm{\Theta}{\Upsilon}{\tau} &\triangleq & \MkSet{M\mid\IsAbt{\Theta}{\Upsilon}{\cdot}{M}{\tau}}\\
      D &\in &\SemDecl &\triangleq & \coprod_{\Upsilon,\Theta,\tau} \SemTerm{\Theta}{\Upsilon}{\tau}\\
      \Sigma &\in &\SemSig &\triangleq & \Partial{\SemOpid}{\SemDecl}
    \end{array}
  \end{displaymath}
  \caption{Specification of the semantic objects.}
  \label{fig:sig-semantic-objects}
\end{figure}

\newcommand\Elab[3]{%
  \IMode{#1}\vdash%
  \IMode{#2}\Longrightarrow%
  \OMode{#3}
}

A \emph{natural semantics} hinges on the elaboration judgment
$\Elab{E}{A}{A'}$, which means that the syntactic object $A$ elaborates to the
semantic object $A'$ in the environment $E$. Let the
$\Member{\Upsilon_\Sigma}{\SemParams}$ be defined as follows:
\[
  \Define{\Upsilon_\Sigma(\vartheta)}{
    \left\{
      \begin{array}{ll}
        \AbtSortOpid & \textit{if}\quad \vartheta\in\mathbf{dom}(\Sigma)\\
        \bot & \textit{otherwise}
      \end{array}
    \right.
  }
\]

\subsection*{Symbol Bindings\hfill \framebox{$\Elab{\Sigma}{\SortSymBind}{(a,\tau)}$}}

\begin{gather}
  \infer{
    \Elab{\Sigma}{\Bind{\SortSymId}{\SortSortId}}{(a, \tau)}
  }{
    \Elab{\Sigma}{\SortSymId}{a} &
    \Elab{\Sigma}{\SortSortId}{\tau}
  }
\end{gather}

\subsection*{Metavariable Bindings\hfill \framebox{$\Elab{\Sigma}{\SortMetaBind}{(\MV{m},v)}$}}

\begin{gather}
  \infer{
    \Elab{\Sigma}{\Bind{\SortMetaId}{\SortValence}}{(\MV{m}, v)}
  }{
    \Elab{\Sigma}{\SortMetaId}{\MV{m}} &
    \Elab{\Sigma}{\SortValence}{v}
  }
\end{gather}

\subsection*{Parameters\hfill \framebox{$\Elab{\Sigma}{\SortParams}{\Upsilon}$}}

\begin{gather}
  \infer{
    \Elab{\Sigma}{\EmptyCtx}{\{\}}
  }{
  }\\[6pt]
  \infer{
    \Elab{\Sigma}{\ExtendCtx{\SortParams}{\SortSymBind}}{
      \Upsilon\cup{a \mapsto\tau}
    }
  }{
    \Elab{\Sigma}{\SortParams}{\Upsilon} &
    \Elab{\Sigma}{\SortSymBind}{(a, \tau)}
  }
\end{gather}

\subsection*{Arguments\hfill \framebox{$\Elab{\Sigma}{\SortArgs}{\Theta}$}}

\begin{gather}
  \infer{
    \Elab{\Sigma}{\EmptyCtx}{\{\}}
  }{
  }\\[6pt]
  \infer{
    \Elab{\Sigma}{\ExtendCtx{\SortArgs}{\SortMetaBind}}{
      \Theta\cup{\MV{m} \mapsto v}
    }
  }{
    \Elab{\Sigma}{\SortArgs}{\Theta} &
    \Elab{\Sigma}{\SortMetaBind}{(\MV{m}, v)}
  }
\end{gather}

\subsection*{Operator Identifiers\hfill \framebox{$\Elab{\Sigma}{\SortOpId}{\vartheta}$}}

\begin{gather}
  \infer{
    \Elab{\Sigma}{\SortOpId}{\vartheta}
  }{
    \IMode{\vartheta}\not\in\IMode{\mathbf{dom}(\Sigma)}
  }
\end{gather}

\subsection*{Declarations\hfill \framebox{$\Elab{\Sigma}{\SortSigDecl}{(\vartheta,D)}$}}

\begin{gather}
  \infer{
    \Elab{\Sigma}{
      \DefDecl{\SortOpId}{\SortParams}{\SortArgs}{\SortSortId}{\SortTerm}
    }{(\vartheta,\Tuple{\Upsilon,\Theta,\tau,M})}
  }{
    \begin{array}{l}
      \Elab{\Sigma}{\SortParams}{\Upsilon}\\
      \Elab{\Sigma}{\SortArgs}{\Theta}\\
    \end{array} &
    \begin{array}{l}
      \Elab{\Sigma}{\SortSortId}{\tau}\\
      \Elab{\Sigma}{\SortTerm}{M}
    \end{array} &
    \begin{array}{l}
      \Elab{\Sigma}{\SortOpId}{\vartheta}\\
      \IsAbt{\Theta}{\Upsilon_\Sigma\oplus\Upsilon}{\cdot}{M}{\tau}
    \end{array}
  }\\[6pt]
  \infer{
    \Elab{\Sigma}{
      \TacDecl{\SortOpId}{\SortParams}{\SortArgs}{\SortTerm}
    }{(\vartheta,\Tuple{\Upsilon,\Theta,\AbtSortTac,M})}
  }{
    \begin{array}{l}
      \Elab{\Sigma}{\SortParams}{\Upsilon}\\
      \Elab{\Sigma}{\SortArgs}{\Theta}\\
      \Elab{\Sigma}{\SortTerm}{M}
    \end{array} &
    \begin{array}{l}
      \Elab{\Sigma}{\SortOpId}{\vartheta}\\
      \IsAbt{\Theta}{\Upsilon_\Sigma\oplus\Upsilon}{\cdot}{M}{\AbtSortTac}
    \end{array}
  }\\[6pt]
  \infer{
    \Elab{\Sigma}{
      \ThmDecl{\SortOpId}{\SortParams}{\SortArgs}{\SortTerm_1}{\SortTerm_2}
    }{(\vartheta,\Tuple{\Upsilon,\Theta,\AbtSortThm,\App{\OpProve}{P;M}})}
  }{
    \begin{array}{l}
      \Elab{\Sigma}{\SortParams}{\Upsilon}\\
      \Elab{\Sigma}{\SortArgs}{\Theta}
    \end{array} &
    \begin{array}{l}
      \Elab{\Sigma}{\SortTerm_1}{P}\\
      \Elab{\Sigma}{\SortTerm_2}{M}
    \end{array} &
    \begin{array}{l}
      \IsAbt{\Theta}{\Upsilon_\Sigma\oplus\Upsilon}{\cdot}{P}{\AbtSortExp}\\
      \IsAbt{\Theta}{\Upsilon_\Sigma\oplus\Upsilon}{\cdot}{M}{\AbtSortTac}
    \end{array} &
    \Elab{\Sigma}{\SortOpId}{\vartheta}
  }
\end{gather}

\subsection*{Signatures\hfill \framebox{$\Elab{}{\SortSigExpr}{\Sigma}$}}

\begin{gather}
  \infer{
    \Elab{}{\EmptySig}{\{\}}
  }{
  }\\[6pt]
  \infer{
    \Elab{}{\ExtendSig{\SortSigExpr}{\SortSigDecl}}{\Sigma\cup\vartheta\mapsto D}
  }{
    \Elab{}{\SortSigExpr}{\Sigma} &
    \Elab{\Sigma}{\SortSigDecl}{(\vartheta, D)}
  }
\end{gather}

\end{document}
